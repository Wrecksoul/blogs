---
title: 我的角度看Unix IO模型
categories:
- I/O
tags:
- I/O
- 系统调用
---
# 关于Unix I/O模型的理解

> 《Unix网络编程 卷一》：
> POSIX把这两个术语定义如下：
> - 同步I/O操作（synchronous I/O Operation）导致请求进程阻塞，直到I/O操作完成；
> - 异步I/O操作（asynchronous I/O Operation）不导致请求进程阻塞。

在我看来这只是一个关于I/O的书面定义，生活工作中人们所说的同步和异步跟I/O并不一定相关，就算I/O相关跟这个定义的差别也可能很大。

## 系统调用

> 在电脑中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。

以上是维基百科的定义。
<!--more-->

计算机中，`硬件`是躯体、`软件`是灵魂，我们所编写程序当设计到网络和文件I/O的时候，一定少不了硬件来帮忙，而硬件资源不是直接可以调用的，操作系统充当媒介，系统调用就是操作系统提供给上层应用级程序的接口。

*当然，你翻阅更多的资料，比如恐龙书，会发现系统调用并不是直接被上层程序使用的，而是在对外提供应用程序接口（API）的形式提供，可以简单的理解为应用程序接口是系统调用的一层包装，但是这些不影响我们理解和编程，人们往往直接说系统调用。详情见《操作系统概念 第七版》2.3节系统调用。*

系统调用时cpu或者说进行系统调用的线程进入内核态，拥有了更高的权限从而可以执行与硬件交互的驱动程序代码，*这个是操作系统的一种自我保护机制，不懂的话请自行google*。进入内核态之后，线程将切换用户栈到内核栈。这个时候进行的函数调用可能会触发硬件的一系列变化，比如网络I/O相关的系统调用会导致网卡驱动程序相关代码的执行，从而把网卡内部的缓存信息传输到内核的缓存区域，而后可能又会触发新的系统调用，从内核缓存区域将信息传输到用户缓存区域，数据到达用户缓存区域后，用户代码可以访问，这时候可以结束系统调用了。

> 内核栈是系统运行在内核态的时候使用的栈，用户栈是系统运行在用户态时候使用的栈。当进程由于中断进入内核态时，系统会把一些用户态的数据信息保存到内核栈中，当返回到用户态时，取出内核栈中得信息恢复出来，返回到程序原来执行的地方。用户栈就是进程在用户空间时创建的栈，比如一般的函数调用，将会用到用户栈。
> 
> 至于为什么一个线程为什么同时有两个栈，还是因为考虑到安全的问题，这是操作系统的一种设计，详情请自行google。

## 理解Unix 5种 I/O模型
### 阻塞式io：
![](http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/zuseshiio.png)
如上图所示，阻塞式I/O模型从开始进行系统调用就一直阻塞，就像我在系统调用一节提到的。

程序需要从UDP协议接收几个字节的信息，调用如图所示的`recvfrom`函数，当进程因系统调用而陷入内核态之前，进程所使用的堆栈要从用户栈转到内核栈，先把用户态堆栈的地址保存在内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换，完全一系列的安全检查后，进程陷入内核态。

进入内核态后，进程可以访问网卡驱动程序等等内核空间才可执行的内容，这个时候会导致有一些硬件操作，所谓的等待数据报准备好就是等待网卡中的数据进入主存（内核空间），此时线程肯定是阻塞（这里的阻塞和前面提到的阻塞是一毛一样的）的，当数据报准备好时——需要把数据报从主存的内核空间复制到计算机主存的用户空间的缓存区（用户代码可以直接操作的区域），此时系统调用就可以结束了。

*我的疑惑：
开始我不理解的点在于，为什么开始执行内核空间的程序的时候仍然使用的此线程的调用栈，虽然从用户栈转到了内核栈，但是依旧是这个线程在跑啊，为什么叫做线程阻塞呢？我的感觉是数据从网卡的内存移动到主存的过程，如果使用DMA，cpu是不需要干预的，那么线程肯定就被阻塞了，如果不是使用DMA，那么这个时候cpu需要不断的拷贝数据应该也不算是阻塞吧，当然了如果此时cpu并不是使用当前线程来进行拷贝而是新建了一个线程或网卡驱动一直有一个进程在运行的话就很难说了。

不管细节如何，数据从网络设备移动到内核空间都是一定时间的，这段时间内，用户进程被阻塞了。*

系统调用结束时（在内核态之行的最后将保存在内核栈里面的用户栈的地址恢复到堆栈指针寄存器即可。这样就实现了内核栈和用户栈的互转），回到用户态。进程不再处于阻塞状态，进入就绪状态等待调度。

### 非阻塞式io：

![](http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/feizuseshiio.png)

系统调用的过程和上一种是类似的，只对不同的地方进行说明。


> 进程把一个套接字设置成非阻塞的，就是在通知内核，当所请求的I/O操作非得把本进程投入睡眠才能完成时，不用把本进程投入睡眠，而是返回一个错误。

具体细节我们不必深究，只需要知道由于网络连接所使用的连接被预先设置成非阻塞的了，导致我们进行`recvfrom`系统调用时，第一阶段数据报没有准备好时，进程没有进入阻塞状态，而是立即受到一个返回结果——EWOULDBLOCK错误。直到数据报准备好——进入了主存内核空间区域，才开始复制数据到用户空间，由于这个过程设计到内核空间，肯定还是需要系统调用（`recvfrom`）才能完成的，这时候还是上面`我的疑惑`提到的那个问题。


### io复用：

![](http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/iofuyong.png)
这种模式在我看来是最与众不同的一个，它使用两个系统调用，第一个检测是否有数据报准备好，第二个还是我们的老朋友`recvfrom`负责复制数据报。看起来跟阻塞I/O没有区别，而且还增加了一个系统调用。

但是这种模式下，线程不再阻塞于真正的I/O操作上，而是阻塞select或者poll这样的数据报检查操作上，而这个操作可以同时检查多种状态，并且可以检查多个套接字的状态，这就是所谓的复用，从中文名字上很难理解复用了什么。**但是它有另一个中文名称——事件驱动**，比如数据报准备好了，就是一个事件，一个select系统调用可以同时监控多个套接字通道的多个事件，这就是所谓的复用。看到这里，是不是感觉事件驱动跟信号驱动又有些相似了，区别在于，事件驱动不需要注册一个回调函数，而是直接调用一个系统调用就可以了。而信号驱动式在回调函数中调用`recvfrom`，也可以有其他逻辑，更加多样。

### 信号驱动io：

![](http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/xinhaoqudongio.png)

信号驱动I/O模型中，套接字被开启信号驱动式I/O功能，通过系统调用`sigaction`安装一个信号处理函数，这个系统调用立即返回，并且被设置的函数将在稍后被一个SIGIO信号触发。当数据报没有准备好的时候，由于之前的系统调用已经返回了结果，所以用户进程没有阻塞，也不需要像非阻塞I/O模型中一样轮询检测；当数据报准备好的时候，SIGIO信号产生，信号处理函数触发，函数内部调用`recvfrom`读取数据报。后面的情况跟前面是一样的，就是继续系统调用复制数据到用户空间缓存区。
### 异步io：
![](http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/yibuio.png)
> 《Unix网络编程卷一》原文：
> 异步I/O（asynchronous I/O）由POSIX规范定义，演变成当前POSIX规范的各种早期标准定义的实时函数中存在的差异已经取得一致。一般地说，这些函数的工作机制是：告知内核启动某个动作，并让内核 在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。这种模型与前一节介绍的信号驱动模型的主要区别在于：信号驱动式I/O是由内核通知我们何时启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。图6-5给出了一个例子。
> 我们调用aio_read函数（POSIX异步I/O函数以aio_或lio_开头），给内核传递描述符、缓冲区指针、缓冲区大小（与read相同的三个参数）和文件偏移（与lseek类似），并告诉内核当整个操作完成时如何通知我们。该系统调用立即返回，而且在等待I/O完成期间，我们的进程不被阻塞。本例子中我们假设要求内核在操作完成 时产生某个信号。该信号知道数据已经复制到进程缓冲区才产生，这一点不同于信号驱动式I/O模型。
> *本书编写至此，支持POSIX异步I/O模型的系统仍较罕见。我们不能确定这样的系统是否支持套接字上的这种模型。这儿我们只是用它作为一个与信号驱动式I/O模型相比照的例子*

根据上面的描述，我们可以知道，异步I/O跟信号驱动式I/O非常类似，只是
1. 它的第一步系统调用时需要注册的函数更加复杂，因为它需要告诉内核将数据传输到用户空间的具体位置以及数据的大小，同时还需要告知内核到时候需要调用什么回调函数。
2. 内核也需要独立执行数据从网卡---》内核缓冲区（也许被跳过）---》用户缓冲区的操作。


### 五种模型的比较：

![](http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/5zhongmoxing.png)

比较以上5种模型，可见前四种都调用了`recvfrom`这个系统调用，而这个过程都导致了进程被阻塞。所以之后最后一个模型与POSIX所定义的异步I/O相匹配。

{% note danger %}注意，在《Unix网络编程 卷一》中，描述到匹配两个字就结束了，并没有提到如“只有最后一个模型才是异步I/O这种话”，而我看到有些资料都这样推理出来这样的结论。我想说的是，这本书并不是一个理论定义的书，就像我们程序员一样，作者恐怕并不关心什么是所谓的定义的异步I/O，你只需要区分出5种模型的区别，并有利于你理解各种编程模型就OK了，顺便提一句到目前为止Linux中依然不存在真正的异步I/O系统调用，这也是为什么Netty把异步I/O添加又删除掉的原因。{% endnote %}

# 关于同步、异步用词上的一点小看法
编程中经常遇到同步、异步这两个词，开始接触的时候感觉很难理解，很多时候这两个词的翻译来源于Synchronize和Asynchronize。

理解这个概念的难点其实很简单，就是没有主语。什么同步，什么异步？搞清楚这个就好了。

## 同步
在java中使用Synchronized关键字进行同步处理的时候，同步的是数据，通过一个粗粒度锁的争夺，只有一个线程可以进行相关数据的操作，达到的最终目的是保证了临界区的代码所处理的数据或者数据块在多个线程拿到的时候是一致的。

> 记得有一个经典的，但是听起来有些像废话的，对于线程安全的定义如下：
> 如果代码在多线程的环境下的运行，每次的运行结果和单个线程下结果是一样的，而且相关变量的值和预期也是一样的，这种情况就是线程安全的。

线程不安全的问题往往是数据在多个线程下不同步导致的，解决方法当然就是使多个线程中的数据能够彼此一致（同步）。当然额外说一句，最简单的解决方法就是多线程操作数据时，同一时间只有一个线程可以获取到数据并进行操作（原子性）并且

比如我们的主从数据库，需要做的就是主数据库向从库做同步操作，这个就是在同步数据，或者说**使双方数据变的一致**。

如果程序中发生线程不安全的情况，往往就是数据不同步导致的，两个线程没有拿到双方所处理的各自的最终结果，发生了数据的覆盖的情况，即发生了数据的不同步。我猜这就是为什么java最初的同步API，使用的是同步（Synchronized）这个单词作为关键字了。

很显然异步这个词用在这里就不合适了，我们不能说数据是异步的。

## 异步
说异步的时候，我们往往指的是时间上的异步，或者指的是两个动作可以同时进行不互相**等待**。
比如在nodejs中大量的使用异步，在js的ajax函数中也可以支持异步行为，他们的共同点都是让一个动作的发生不需要等待另一个动作完成。这是两个动作在时空上的同时进行。

说到底，异步这个词翻译的真烂，同时进行叫异步？

## 同步与异步是反义词吗？
同步往往指数据同步，异步往往指动作同时进行。
想想他们的反面，
1. 数据不同步了叫异步吗？NO
2. 动作可以不互相等待叫做异步，互相等待呢，好吧叫同步，但是其实我们不怎么说，而是说非异步的


## 阻塞
说到等待，可能又要扯上一个词——阻塞。其实阻塞这个词的应用范畴是很小的，它的来源也很简单，cpu对于无法继续运行的线程的一种行为，在I/O模型中，异步I/O也是强调用户线程只需要发出一个数据的请求最后收到数据到达的通知（就像你网上下订单，快递小哥送货的时候才通知你一样）

*简单说一下，线程有3个状态：就绪、运行和阻塞（也有说5个状态，加上创建和死亡，不过那个不重要啦）。就绪就是可以运行，但是当前没有被调度，不处于运行状态。而阻塞时不可以运行，没有满足需要的条件，往往等待什么东西到达，所以才处于不运行状态。*

可见阻塞所侧重的点跟同步是完全不同的，阻塞强调的是多线程方面的，线程是否不再占用cpu进入一个等待的状态，而这里的同步是作为异步的反面来说的，重点强调需要等待另一个任务完成才能继续运行。



## 再次混为一谈

POSIX的定义由把同步和阻塞加一块了，同步的就是阻塞，异步的就是不阻塞。上面我们说过，异步往往是时间上的异步，指两个动作可以同时进行不互相**等待**，看完`理解Unix 5种 I/O模型`这部分的内容，你的理解变了吗？

一种描述是：

- 异步是让进程之间的分工更加明确，尽量少的交叉，提高效率但是在实现方式上增加了复杂性；

- 而同步是串行的操作更多，逻辑上更加简单，但是效率较低，cpu利用率下降。

## 举个例子：
网购从下单到收快递，送货一般来说是不需要买家参与的，你只需要下单就可以了，等货物到时候你会受到通知，但是想象一个很现实的剧情，如果快递小哥要求你必须在家才把快递放下的话，你就需要等待快递小哥的到来，此间不能做其他事情（比如旅行、打球等），而如果你家门口有一个很有保障的邮箱之类的，快递小哥可以放心的把东西放过去，你只是收到‘收货成功’的通知而不需要在家等待的话，这样就实现了完全的异步。

从上面的例子看，即使快递小哥你需要在家等待送货，这种情况其实也是有异步的成分的，比如卖家发货期间、快递跨省运送期间，你不需要在家持续~~阻塞~~等待。
如果需要的话，那这种情况就跟阻塞I/O没什么两样了，因为从下订单开始你都要一直等着并且做不了任何事情。

### 需要指出的是
POSIX把异步I/O定义成完全异步的那种模型（第五种），可以理解为，这是书面上的一种定义，而且人家也只是定义了操作系统I/O，并没有定义“异步”这个词的有效范畴。