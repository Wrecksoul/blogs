---
title: 操作系统是如何启动的
categories:
- 杂谈
tags:
- 操作系统
---

## 开机启动？
由于内存无法在不通电的时候是无法保持数据的，所以开机的时候内存是空的，CPU自身也不能存储数据，在这个盘古开天辟地混沌初开的时候，还没操作系统什么事儿呢，因为操作系统的程序在磁盘中，还没有加载到内存呢，CPU也就没法执行它。CPU就是空有一身力气但是没处使啊。

此时一个非常矛盾的情况是，如果操作系统想运行的话，就需要把操作系统的代码加载到内存中，但是想把程序加载到内存中则需要操作系统启动之后才能做。这个有点矛盾的过程导致了开机的英文不是power on 不是 start up 而是bootstrap，简称boot。

<!--more-->
## bootstrap

> 启动的英文是bootstrap，来源于"pull oneself up by one's bootstraps"这句谚语。
> 字面意思是"拽着鞋带把自己拉起来"，这当然是不可能的事情。
> 
> 最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！
早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做"拉鞋带"，久而久之就简称为boot了。

这时候我们需要硬件来帮忙，说白话就是有一个**固定的开机程序**，只要一通电CPU就自动运行的那种程序——BIOS。它是利用硬件操作完成程序向内存的加载、CPU接收并执行第一条指令，所以这时候就不存在之前所说的矛盾了，其实具体我不懂，这些事情跟硬件什么的关系比较密切了，我就不深究了。反正BIOS运行时CPU所处的模式不同于运行操作系统的时候，而且还需要进行显示器、键盘、其他I/O设备等等连接操作、各种检查操作。

**需要说明的是，这个时候内存肯定是CPU已经在用了，虽然此时肯定没有操作系统什么事情。所以啊，待会加载boot loader或者操作系统程序到内存的时候，就需要约定好了哪些内存地址可以用哪些不可以用，要不然容易互相覆盖了。**

## BIOS加载MBR
BIOS中程序做的很重要的一件事情就是把一段数据从I/O设备加载到内存中，并且让CPU可以执行这段程序。
由于软件纷繁复杂、操作系统多种多样，让BIOS去加载操作系统就太不灵活了，因为BIOS是在主板上的，如果让BIOS去加载操作系统那就很容易造成，我们买了计算机只能装某一种操作系统了。

## Boot 的 Loader

刚说了BIOS不加载操作系统。

而CPU之前运行的一直是BIOS里面的程序，现在那段程序的任务结束了，下一步要交给别的程序了。

是谁呢？这里BIOS有一个非常灵活的设定，它提供一个有序列表，让用户可以选择，对了看看下面的图，这个蓝底白字的界面是不是似曾相识，一般是开机的时候按F1/F2/DEL/F12之类的进去，有一个叫 `boot sequece` 选项卡，里面可以设置有序列表。

![](http://image.beekka.com/blog/201302/bg2013021504.jpg)

在I/O设备的前512字节上，都有一个叫做"主引导记录"（Master boot record，缩写为MBR）的地方，这个地方是软硬件工程师们约定好的，然后利用BIOS自身的中断指令去加载它，注意，此时没有什么文件系统格式的概念，就是字节，每个字节都有规定好的含义，这些字节有什么含义呢？看下面。

### MBR

由三部分组成：
1. 第1-446字节：调用操作系统的机器码。
2. 第447-510字节：分区表（Partition table）。
3. 第511-512字节：主引导记录签名（0x55和0xAA）。

这第三部分就是BIOS检查设备是否属于引导设备的时候的一个依据，比如你的普通U盘前面第511-512字节肯定不是这个，但是当你利用一些工具比如UltraISO或者大白菜什么的把它做成centos系统启动的话，这 `主引导记录签名` 肯定就会变成0x55AA了。

由于我们的终极目的是需要完成的就是去加载windows或者linux或者其他操作系统的核心程序。

而如果要执行操作系统初始化的那些程序，那么就要求这些程序加载到内存中，谁去加载呢？由于不同操作系统使用的格式各不相同，甚至产品理念各不相同，这些程序的名称启动顺序更加不同了。这就需要各种不同的操作系统厂商自行提供各自启动程序的载入程序。

这部分程序的目的是载入我们希望运行其他程序，解决的是其他程序的载入（Load，载入内存中）问题，所以又叫做 `Boot loader`。

`Boot Loader` 可以放在 `MBR` 中，使得它们可以在被BIOS运行完成后加载并运行起来。

### 多系统

正常来说经历了：

```
通电 ---> BIOS运行，载入I/O设备MBR区 ---> MBR中的Boot Loader载入操作系统核心程序 ---> 系统启动完成
```
这些之后系统应该可以启动了。

**但是**，为了更加灵活的目的，比如我们想一个计算机装两个互不相干的操作系统。Boot Loader跟BIOS一样有一个灵活设计，它可以给我们提供选择列表，具体去加载哪个操作系统用户可以自行选择。但是这个选择是基于系统分区这么个概念来的。看看上面MBR的第二部分内容——分区表。看看我盗了图：

![](http://ozhp30d7a.bkt.clouddn.com/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E6%9E%9C%E5%90%AF%E5%8A%A8%E7%9A%84/MBRfenqu.png)

上面这个图画的相当清楚，我们可以看到主引导记录（MBR）分了三部分，虽然它画的主引导记录比例非常小，但是我们必须知道它有466个字节，BootLoader程序就在这里了，而分区表只有64字节，最后的签名只有2个字节。

图中的引导扇区是叫做VBR（卷引导记录，英文volume boot record），要实现多系统就需要它们的参与。VBR跟MBR非常类似都是512B大小，而且都有BootLoader。

下面这张图像说明的情况跟上面的图很相似，只是侧重点不同：

![](http://ozhp30d7a.bkt.clouddn.com/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E6%9E%9C%E5%90%AF%E5%8A%A8%E7%9A%84/mbr_boot_sector.gif)

需要注意的是，BootLoader的灵活性是有限的，并不是一个BootLoader可以加载两种操作系统，而是BootLoader可以加载其他系统的BootLoader。看看我从鸟哥的linux私房菜盗的图吧：

![](http://ozhp30d7a.bkt.clouddn.com/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E6%9E%9C%E5%90%AF%E5%8A%A8%E7%9A%84/loader_menu.gif)

如上图所示，MBR 使用Linux 的grub2 这个开机管理程序，并且里面假设已经有了三个选单， 第一个选单可以直接指向Linux 的核心文件并且直接载入核心来开机；第二个选单可以将开机管理程序控制权交给Windows 来管理，此时Windows 的loader（NTLDR/bootmgr/grldr等） 会接管开机流程，这个时候他就能够启动windows 了。第三个选单则是使用Linux 在boot sector（引导扇区，见图5，其实就是VBR）内的开机管理程序，此时就会跳出另一个grub2 的选单啦！

选单一：MBR(grub2) --> kernel file --> booting
选单二：MBR(grub2) --> boot sector(Windows loader) --> Windows kernel --> booting
选单三：MBR(grub2) --> boot sector(grub2) --> kernel file --> booting
而最终boot loader的功能就是『载入kernel档案』啦！

**另外**，我找到一个翻译 `GRUB2` 官方手册的：[对grub2的详细介绍](http://www.php.cn/linux-371649.html)

## 总结

由上面可以知道：

1. 通电
2. BIOS运行，BIOS按照有序列表寻找可以用于启动的磁盘，主要就是验证各个设备MBR的签名是否是0x55AA
3. BIOS通过一一验证找到了引导设备。
4. 引导设备的MBR已经被加载到0x7c00-0x7dff这段内存上（是的，已经加载了，否则怎么验证啊）
5. MBR引导程序开始运行，此时分2种情况
	1. 直接加载操作系统，这种往往是操作系统在MBR处安装了自己的BootLoader。
	2. 根据分区表找到并加载活动分区（MBR中有记录哪个是活动分区）中的VBR。VBR也是512B大小，并且会占据开始MBR占据的内存空间，而MBR会在加载VBR之前把自己拷贝到别的内存地址上去的。
	3. 其实第二条中说的MBR查找活动分区又分两种情况，活动分区是主分区和逻辑分区，也就是说，系统是安装在了主分区上还是逻辑分区上，不过不管是安在哪后面的步骤都是加载活动分区的VBR，而且系统安装在逻辑分区上的情况非常少见，有的文章说到windows只能安装在主分区类型的活动分区上，看来安装在逻辑分区上的只能是LINUX了。
6. MBR的运行分两种情况，刚刚说的是第一种，也是单系统的计算机启动的场景。第二种是MBR安装了GRUB2这种引导程序的情况。所谓**安装**就是说MBR前466自己的逻辑代码被替换成了GRUB2这种程序了。GRUB2会去硬盘上一个位置读取配置文件，根据配置文件提供一个选择列表供用户选择，选择之后会直接加载相应的操作系统，或者加载操作系统对应的boot loader。

**全是windows惹的祸**：
- windowns除了在自己所在分区的boot sector（VBR）上安装自己的boot loader，它还会在硬盘的MBR上也装上一份（linux的brub2提供用户选项是否覆盖），具体这个MBR上的程序是去加载VBR还是直接加载操作系统我就不清楚了，不过也无所谓啦。
- 不过Windows 的boot loader 预设不具有控制权转交的功能，也就是说windows的 boot loader 无法因此你不能使用Windows 的boot loader 来载入Linux 的loader 。但是倒是可以通过easyBCD这种程序来后期更改。

装Linux和windows双系统为啥这么困难，知道谁的锅了吧。

## 不知道我在说啥

如果你在想“不知所云，作者是个傻X”。囧

没关系，其实我也想到了，这个文章注意是记录我的一些思路，而且我语言水平有限嘛。但是你可以看看这个[阮一峰-计算机是如何启动的](http://www.ruanyifeng.com/blog/2013/02/booting.html)，[桌面电脑操作系统开发笔记（1）——MBR和VBR](http://blog.csdn.net/Firas/article/details/25959267)和[MBR及linux下grub执行原理浅析](http://blog.csdn.net/zhongjin616/article/details/17630357)和[BIOS, boot loader 与kernel 载入--鸟哥的Linux私房菜](http://linux.vbird.org/linux_basic/0510osloader.php#startup)

*我之前装LINUX和WIN双系统就各种不懂，而且WIN10更新还让LINUX启动不了。虽然我感觉我想弄清这部分内容即有硬件有软件，还有点底层，但是我又没什么耐心弄清所有的技术细节，我就想啊，难道就没人从一个宏观的角度通俗易懂把计算机启动操作系统这回事给我说一说吗？看了一下文章感觉写的不是很全面总是云里雾里的，当然了可能是我理解能力不够啦，于是我开始看各种操作系统有关的书籍。所以我想自己弄懂它，然后用自己的话描述出来。所有才有了这一段不知所云的话。*

## 题外话

现在还有UEFI和GPT这两种新的跟启动相关的东西，具体我还没有看，等弄懂了得空再加再补充一下。
