<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blogs/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/blogs/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blogs/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/blogs/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="并发,J.U.C," />










<meta name="description" content="前言本文对java 6/7 java.util.concurrent.locks的主要接口和抽象类的API进行不完全的翻译，写了一点个人理解，并且对API分了段落。 个人感觉在看那些网上的各种详解教程之前应该先读一下源码中的API注释，这有利于在理解各种同步类源码的时候能纵观全局统筹兼顾，起到窥一斑而知全貌的效果。毕竟Doug Lea才是最懂JUC包的人而他本人写的注释更是最正确的解释，所以看看A">
<meta name="keywords" content="并发,J.U.C">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发个人总结——locks API">
<meta property="og:url" content="https://wrecksoul.github.io/blogs/2018/01/09/Java并发API_locks/index.html">
<meta property="og:site_name" content="Walker&#39;s blogs">
<meta property="og:description" content="前言本文对java 6/7 java.util.concurrent.locks的主要接口和抽象类的API进行不完全的翻译，写了一点个人理解，并且对API分了段落。 个人感觉在看那些网上的各种详解教程之前应该先读一下源码中的API注释，这有利于在理解各种同步类源码的时候能纵观全局统筹兼顾，起到窥一斑而知全貌的效果。毕竟Doug Lea才是最懂JUC包的人而他本人写的注释更是最正确的解释，所以看看A">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-01-25T09:15:29.578Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java并发个人总结——locks API">
<meta name="twitter:description" content="前言本文对java 6/7 java.util.concurrent.locks的主要接口和抽象类的API进行不完全的翻译，写了一点个人理解，并且对API分了段落。 个人感觉在看那些网上的各种详解教程之前应该先读一下源码中的API注释，这有利于在理解各种同步类源码的时候能纵观全局统筹兼顾，起到窥一斑而知全貌的效果。毕竟Doug Lea才是最懂JUC包的人而他本人写的注释更是最正确的解释，所以看看A">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blogs/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wrecksoul.github.io/blogs/2018/01/09/Java并发API_locks/"/>





  <title>java并发个人总结——locks API | Walker's blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blogs/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Walker's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blogs/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blogs/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blogs/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blogs/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blogs/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wrecksoul.github.io/blogs/blogs/2018/01/09/Java并发API_locks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Walker">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ozhp30d7a.bkt.clouddn.com/index/header/shadowmoon-valley-1366x768.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Walker's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java并发个人总结——locks API</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-09T11:14:51+08:00">
                2018-01-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文对java 6/7 java.util.concurrent.locks的主要接口和抽象类的API进行不完全的翻译，写了一点个人理解，并且对API分了段落。</p>
<p>个人感觉在看那些网上的各种详解教程之前应该先读一下源码中的API注释，这有利于在理解各种同步类源码的时候能纵观全局统筹兼顾，起到窥一斑而知全貌的效果。毕竟Doug Lea才是最懂JUC包的人而他本人写的注释更是最正确的解释，所以看看API肯定没坏处。</p>
<p>本文翻译了三个接口（Lock、Condition、ReadWriteLock）一个抽象类（AQS）。</p>
<a id="more"></a>
<div class="note danger"><p>敬告：本文在某种意义上有点像中学的阅读理解解析，主要是我记录一些我阅读中理解历程，有些冗长受不了话请火速离开现场。</p></div>

<h2 id="j-u-c-locks和早期锁对比"><a href="#j-u-c-locks和早期锁对比" class="headerlink" title="j.u.c.locks和早期锁对比"></a>j.u.c.locks和早期锁对比</h2><p>java5之前的多线程编程在锁方面就只有 <code>synchronized</code> 关键字，在线程互相协调方面有 <code>Object</code> 类中的几个方法（<code>wait, notify and notifyAll</code>等）使用起来有很多局限性，所以在java5中加入了JUC包，而JUC包中的locks子包中提供了锁的接口及实现。</p>
<p>总的来说：</p>
<ol>
<li>Lock接口是锁的统一接口，它的实现类所要起的作用和synchronized关键字一样，但是提供了更加灵活的用法和<strong>某些条件下</strong>更好的性能；</li>
<li>Condition接口是线程之间互相协调这样一个动作的统一接口，它的实现类所要起的作用和<code>wait, notify and notifyAll</code>方法起到的作用相同，但是提供了更加灵活的用法。</li>
<li>AQS（AbstractQueuedSynchronizer）是一个工具性的抽象类，它的存在不像上面两个接口一样为了定义标准，它提供工具性的方法，一方面方便子类的实现并减少代码冗余，一方面利用这些工具方法它定义了锁等待、锁获取的运行机制（模板方法模式），它以一种特定的方式（AQS的API中会提到）提供服务，剧透一点，它的子类不是锁实现类，而是锁类的一个成员，锁实现类利用此引用完成各种锁操作。</li>
</ol>
<h2 id="Lock接口和synchronized"><a href="#Lock接口和synchronized" class="headerlink" title="Lock接口和synchronized"></a>Lock接口和synchronized</h2><h3 id="Lock的作用"><a href="#Lock的作用" class="headerlink" title="Lock的作用"></a>Lock的作用</h3><p>Lock接口的实现类主要用于代替synchronized关键字并且提供更多功能，在Lock接口的API中主要说明了synchronized关键字的局限性。</p>
<blockquote>
<p>Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects.</p>
</blockquote>
<p>Lock接口的实现类提供了相对于synchronized关键字修饰的方法或者代码块更加广泛的锁操作，他们允许更加灵活的结构，允许拥有十分不同的属性，可以支持多个与锁相关联的 Condition 接口的对象。</p>
<blockquote>
<p>A lock is a tool for controlling access to a shared resource by multiple threads. Commonly, a lock provides exclusive access to a shared resource: only one thread at a time can acquire the lock and all access to the shared resource requires that the lock be acquired first. However, some locks may allow concurrent access to a shared resource, such as the read lock of a ReadWriteLock.</p>
</blockquote>
<p>一个锁时控制多线程访问共享资源时访问权限的控制工具。一般，一个锁提供一个唯一的访问共享资源的权限：同一时间只有一个线程可以获取锁，并且所有共享资源的访问都需要首先获取到锁才行。当然有些锁也允许共享资源的并发访问，比如 <code>ReadWriteLock</code> 的读锁（read lock）。</p>
<h3 id="与synchronized对比"><a href="#与synchronized对比" class="headerlink" title="与synchronized对比"></a>与synchronized对比</h3><blockquote>
<p>The use of synchronized methods or statements provides access to the implicit monitor lock associated with every object, but forces all lock acquisition and release to occur in a block-structured way: when multiple locks are acquired they must be released in the opposite order, and all locks must be released in the same lexical scope in which they were acquired.</p>
<p>While the scoping mechanism for synchronized methods and statements makes it much easier to program with monitor locks, and helps avoid many common programming errors involving locks, there are occasions where you need to work with locks in a more flexible way. For example, some algorithms for traversing concurrently accessed data structures require the use of “hand-over-hand” or “chain locking”: you acquire the lock of node A, then node B, then release A and acquire C, then release B and acquire D and so on. Implementations of the Lock interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order.</p>
</blockquote>
<p><code>synchronized</code>修饰的方法和代码块利用的是隐式监视器锁（对象锁，每个对象都关联一个），但是却强制所有锁的获取和释放都需要发生在同一个块结果中：当多个锁被获取时它们被释放的顺序必须跟获取相反，并且且必须在与锁被获取时相同的词法范围内释放所有锁。（注：其实就是说，synchronized是全自动化设计，进入代码块就获取锁，出代码块就释放锁，由于用代码块来控制资源界限，多个锁获取和释放自然是多个代码块嵌套，释放顺序自然就固定了。）</p>
<p>虽然范围机制使得<code>synchronized</code>修饰的方法和代码块提供的锁机制使用起来更简单而且还帮助避免了很多涉及到锁的常见编程错误，但是有一些场景下你需要以更加灵活的方式使用锁。例如，某些遍历并发访问数据结构的算法要求使用称为 “hand-over-hand” 或 “chain locking”的获取方式：获取节点 A 的锁，然后再获取节点 B 的锁，然后释放 A 并获取 C，然后释放 B 并获取 D，依此类推。Lock 接口的实现允许锁在不同的作用范围内获取和释放，并允许以任何顺序获取和释放多个锁，从而支持使用”hand-over-hand”这种技术实现。</p>
<h3 id="灵活的代价"><a href="#灵活的代价" class="headerlink" title="灵活的代价"></a>灵活的代价</h3><blockquote>
<p>With this increased flexibility comes additional responsibility. The absence of block-structured locking removes the automatic release of locks that occurs with synchronized methods and statements. In most cases, the following idiom should be used:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock l = ...;</span><br><span class="line">l.lock();</span><br><span class="line">try &#123;</span><br><span class="line"> // access the resource protected by this lock</span><br><span class="line">&#125; finally &#123;</span><br><span class="line"> l.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is released when necessary.</p>
</blockquote>
<p>随着灵活性的增加也带来了更多的责任。<code>synchronized</code>修饰的方法和代码块提供的自动释放锁的功能没有了。更多的情况下需要使用如下语句。<br>(代码略)<br>当获取锁和解锁发生在不同的作用域时，必须谨慎地确保保持锁定时所执行的所有代码用 try-finally 或 try-catch 加以保护，以确保在必要时释放锁。 </p>
<h3 id="Lock实现可能提供的额外功能"><a href="#Lock实现可能提供的额外功能" class="headerlink" title="Lock实现可能提供的额外功能"></a>Lock实现可能提供的额外功能</h3><blockquote>
<p>Lock implementations provide additional functionality over the use of synchronized methods and statements by providing a non-blocking attempt to acquire a lock (tryLock()), an attempt to acquire the lock that can be interrupted (lockInterruptibly(), and an attempt to acquire the lock that can timeout (tryLock(long, TimeUnit)).</p>
<p>A Lock class can also provide behavior and semantics that is quite different from that of the implicit monitor lock, such as guaranteed ordering, non-reentrant usage, or deadlock detection. If an implementation provides such specialized semantics then the implementation must document those semantics.</p>
</blockquote>
<p>Lock 实现类提供了使用 synchronized 方法和语句所没有的其他功能，包括：提供了一个<strong>非阻塞</strong>（其实是只尝试一次）的获取锁方法<code>tryLock()</code>、一个<strong>可中断</strong>的获取锁方法 <code>lockInterruptibly()</code> 和一个<strong>超时失效</strong>的获取锁的方法<code>tryLock(long, TimeUnit)</code>。</p>
<p>一个Lock实现类还可以提供与隐式监视器锁完全不同的行为和语义，比如保证排序、不可重入性或死锁检测，如果一个实现类提供了这样的特殊行为和语义的话必须在文档中记录。</p>
<h3 id="切勿这样使用"><a href="#切勿这样使用" class="headerlink" title="切勿这样使用"></a>切勿这样使用</h3><blockquote>
<p>Note that Lock instances are just normal objects and can themselves be used as the target in a synchronized statement. Acquiring the monitor lock of a Lock instance has no specified relationship with invoking any of the lock() methods of that instance. It is recommended that to avoid confusion you never use Lock instances in this way, except within their own implementation.</p>
<p>Except where noted, passing a null value for any parameter will result in a NullPointerException being thrown.</p>
</blockquote>
<div class="note warning"><p>注意Lock 实例只是普通的对象，其本身可以在 synchronized 语句中作为目标使用。获取 Lock 实例的监视器锁与调用该实例的任何 lock() 方法没有特别的关系。为了避免混淆，建议除了在其自身的实现中之外，决不要以这种方式使用 Lock 实例。</p></div>

<p>除非另有说明，否则为任何参数传递 null 值都将导致抛出 NullPointerException。</p>
<p><em>(这段话和Condition API最后的话非常相似)</em></p>
<h3 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h3><blockquote>
<p><em>Memory Synchronization</em><br>All Lock implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in section 17.4 of The Java™ Language Specification:</p>
<ol>
<li>A successful lock operation has the same memory synchronization effects as a successful Lock action.</li>
<li>A successful unlock operation has the same memory synchronization effects as a successful Unlock action.</li>
</ol>
<p>Unsuccessful locking and unlocking operations, and reentrant locking/unlocking operations, do not require any memory synchronization effects.</p>
</blockquote>
<p><em>内存同步</em><br>所有 Lock 实现都<strong>必须</strong>实施与<strong>内置监视器锁</strong>提供的相同内存同步语义，如 The Java Language Specification, Third Edition (17.4 Memory Model) 中所描述的: </p>
<ol>
<li>成功的 lock 操作与成功的 <em>Lock</em> 操作具有同样的内存同步效应。</li>
<li>成功的 unlock 操作与成功的 <em>Unlock</em> 操作具有同样的内存同步效应。</li>
</ol>
<p>不成功的锁定与取消锁定操作以及重入锁定/取消锁定操作都不需要任何内存同步效果。</p>
<p>（斜体的 <em>Lock</em> 和 <em>Unlock</em> 指的是内置监视器锁的锁动作）</p>
<h3 id="实现Lock接口时的注意事项"><a href="#实现Lock接口时的注意事项" class="headerlink" title="实现Lock接口时的注意事项"></a>实现Lock接口时的注意事项</h3><blockquote>
<p><em>Implementation Considerations</em><br>The three forms of lock acquisition (interruptible, non-interruptible, and timed) may differ in their performance characteristics, ordering guarantees, or other implementation qualities. Further, the ability to interrupt the ongoing acquisition of a lock may not be available in a given Lock class. Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of lock acquisition, nor is it required to support interruption of an ongoing lock acquisition. An implementation is required to clearly document the semantics and guarantees provided by each of the locking methods. It must also obey the interruption semantics as defined in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on method entry.</p>
<p>As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after another action may have unblocked the thread. An implementation should document this behavior.</p>
</blockquote>
<p><em>实现注意事项</em><br>三种形式的锁获取（可中断、不可中断和定时）在其性能特征、排序保证或其他实现质量上可能会有所不同。而且，对于给定的 <code>Lock</code> 类，可能没有中断正在进行的锁获取的能力。因此，并不要求实现为所有三种形式的锁获取定义相同的保证或语义，也不要求其支持中断正在进行的锁获取。实现类必须清楚地对每个锁定方法所提供的语义和保证提供清晰的文档说明，还必须遵守此接口中定义的中断语义到这样的程度：完全支持中断，或仅在进入方法时支持中断。</p>
<p>由于中断通常意味着取消，而通常又很少进行中断检查，因此，相对于普通方法返回而言，实现可能更喜欢响应某个中断。即使出现在另一个操作<strong>之后</strong>的中断可能会释放线程锁时也是这样。实现对此行为提供详细文档说明。 (这里是说由于中断检查不是很常见，所以一旦出现中断它的优先级会比较高，“即使出现在另一个操作之后的中断可能是否线程锁时也是这样”，如果这样的话应该是非常危险的吧，因为锁被释放可能会造成线程安全问题。)</p>
<p><strong>其实如果看过具体实现你会发现，所谓的中断，并不是在中间断开，而是在最后执行结束后检查是否有中断。</strong>，这个其实我没有验证过啊。。。。。</p>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>AQS有两个内部类，一个是Node一个是ConditionObject。前者是static final修饰的，不可继承，对于子类来说不需要关心，后者ConditionObject是Condition接口的实现类。</p>
<p>java6/7中，此Condition接口只有两个实现类，分别是 <code>AbstractQueuedLongSynchronizer</code> 和 <code>AbstractQueuedSynchronizer</code> 的内部类都叫做 <code>ConditionObject</code>，其实原理一模一样只是一个使用int一个使用long做核心整型而已。</p>
<h3 id="Condition的作用"><a href="#Condition的作用" class="headerlink" title="Condition的作用"></a>Condition的作用</h3><blockquote>
<p>Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods. </p>
<p>Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to “wait”) until notified by another thread that some state condition may now be true. Because access to this shared state information occurs in different threads, it must be protected, so a lock of some form is associated with the condition. The key property that waiting for a condition provides is that it atomically releases the associated lock and suspends the current thread, just like Object.wait. </p>
</blockquote>
<p>这句话从全局的角度看Condition接口以及它的实现类，可以简单的理解为 <code>Condition</code> 接口的作用就是替代 <code>wait, notify and notifyAll</code> 这些方法，就好似 <code>ReetrantLock</code> 替代 <code>synchronized</code> 关键字一样。上面英文虽然很长但是意思就是这些，如果不了解<code>wait, notify and notifyAll</code> 这些方法的含义当然就没办法理解Condition接口了。</p>
<h3 id="Condition的使用"><a href="#Condition的使用" class="headerlink" title="Condition的使用"></a>Condition的使用</h3><blockquote>
<p>A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition() method. </p>
</blockquote>
<p>这句话非常重点，它指明了此接口的子类不是独立存在的，这有两个方面的限制，一必须是一个内部类，二不能是静态内部类，再看 <code>AbstractQueuedSynchronizer.ConditionObject</code>的声明： <code>public class ConditionObject implements Condition, java.io.Serializable</code> 。当需要获取一个锁实例的条件时调用 <code>newCondition</code> 方法，注意此方法是接口 <code>Lock</code> 定义的。由于是内部类，<code>ConditionObject</code> 的实例一定会绑定在一个 <code>Lock</code> 接口的实例上，即lock可以获取到跟它关联的condition，其实我感觉使用内部类并不是必须的，不过由于内部类天然的可以访问外部类所有成员，所以少了很多传递参数的必要更加方便了。</p>
<blockquote>
<p>As an example, suppose we have a bounded buffer which supports put and take methods. If a take is attempted on an empty buffer, then the thread will block until an item becomes available; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances.</p>
</blockquote>
<p>下面举个例子，假定有一个绑定的缓冲区，它支持 put 和 take 方法。如果试图在空的缓冲区上执行 take 操作，则在某一个项变得可用之前，线程将一直阻塞；如果试图在满的缓冲区上执行 put 操作，则在有空间变得可用之前，线程将一直阻塞。我们喜欢在单独的等待 set 中保存 put 线程和 take 线程，这样就可以在缓冲区中的项或空间变得可用时利用最佳规划，一次只通知一个线程。可以使用两个 Condition 实例来做到这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line">  final Lock lock = new ReentrantLock();</span><br><span class="line">  final Condition notFull  = lock.newCondition(); </span><br><span class="line">  final Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">  final Object[] items = new Object[100];</span><br><span class="line">  int putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">  public void put(Object x) throws InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      while (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">      items[putptr] = x;</span><br><span class="line">      if (++putptr == items.length) putptr = 0;</span><br><span class="line">      ++count;</span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object take() throws InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      while (count == 0)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      Object x = items[takeptr];</span><br><span class="line">      if (++takeptr == items.length) takeptr = 0;</span><br><span class="line">      --count;</span><br><span class="line">      notFull.signal();</span><br><span class="line">      return x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(The ArrayBlockingQueue class provides this functionality, so there is no reason to implement this sample usage class.)<br>A Condition implementation can provide behavior and semantics that is different from that of the Object monitor methods, such as guaranteed ordering for notifications, or not requiring a lock to be held when performing notifications. If an implementation provides such specialized semantics then the implementation must document those semantics.</p>
</blockquote>
<p>（ArrayBlockingQueue 类提供了这项功能，因此没有理由去实现这个示例类。）<br>Condition 实现可以提供不同于 Object 监视器方法的行为和语义，比如<strong>受保证的通知排序</strong>，或者在<strong>执行通知时不需要拥有一个锁</strong>。如果某个实现提供了这样特殊的语义，则该实现必须在文档中详细说明这些语义。（即这种额外的功能性不是每个condition都一定实现需要实现的，具体要看文档。）</p>
<h3 id="切勿这种方式使用"><a href="#切勿这种方式使用" class="headerlink" title="切勿这种方式使用"></a>切勿这种方式使用</h3><blockquote>
<p>Note that Condition instances are just normal objects and can themselves be used as the target in a synchronized statement, and can have their own monitor wait and notification methods invoked. Acquiring the monitor lock of a Condition instance, or using its monitor methods, has no specified relationship with acquiring the Lock associated with that Condition or the use of its waiting and signalling methods. It is recommended that to avoid confusion you never use Condition instances in this way, except perhaps within their own implementation.</p>
<p>Except where noted, passing a null value for any parameter will result in a NullPointerException being thrown.</p>
</blockquote>
<div class="note warning"><p>注意，Condition 实例只是一些普通的对象，它们自身可以用作 synchronized 语句中的目标，并且可以调用自己的 wait 和 notification 监视器方法。获取 Condition 实例的监视器锁或者使用其监视器方法，与获取和该 Condition 相关的 Lock 或使用其 waiting 和 signalling 方法没有什么特定的关系。为了避免混淆，建议除了在其自身的实现中之外，切勿以这种方式使用 Condition 实例。</p></div>

<p>除非另行说明，否则为任何参数传递 null 值将导致抛出 NullPointerException。 </p>
<h2 id="ReadWriteLock接口"><a href="#ReadWriteLock接口" class="headerlink" title="ReadWriteLock接口"></a>ReadWriteLock接口</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><blockquote>
<p>A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for writing. The read lock may be held simultaneously by multiple reader threads, so long as there are no writers. The write lock is exclusive.</p>
</blockquote>
<p>一个读写锁维护这一对相关的锁，一个用于只读操作一个用于写操作。读锁可以被多个读线程同时保持，但写锁是独占的。（写锁不止独占写锁，独占时读锁也不能被获取）</p>
<blockquote>
<p>All ReadWriteLock implementations must guarantee that the memory synchronization effects of writeLock operations (as specified in the Lock interface) also hold with respect to the associated readLock. That is, a thread successfully acquiring the read lock will see all updates made upon previous release of the write lock.</p>
</blockquote>
<p>所有ReadWriteLock的实现类必须保证写锁操作的影响到获取到读锁的线程。换句话说，一个成功获取到读锁的线程可以看到所有写锁的更新内容。</p>
<blockquote>
<p>A read-write lock allows for a greater level of concurrency in accessing shared data than that permitted by a mutual exclusion lock. It exploits the fact that while only a single thread at a time (a writer thread) can modify the shared data, in many cases any number of threads can concurrently read the data (hence reader threads). In theory, the increase in concurrency permitted by the use of a read-write lock will lead to performance improvements over the use of a mutual exclusion lock. In practice this increase in concurrency will only be fully realized on a multi-processor, and then only if the access patterns for the shared data are suitable.</p>
</blockquote>
<p>相比互斥锁，读写锁允许更高级别的并发访问。要满足线程安全，虽然同一时间只能由一个进程修改数据，但是任何数量的进程可以同时读取，读写锁正是利用了这一点。理论上讲，与互斥锁相比，使用读-写锁所允许的并发性增强将带来更大的性能提高。在实际中，只有在多处理器上并且只在访问模式适用于共享数据时，才能完全实现并发性增强。 </p>
<div class="note info"><p><br>1. 为什么必须多处理器呢，因为单处理器实现的多线程读共享数据不是真正的<strong>并行访问</strong>;<br>2. 所谓的合适的访问模式，应该是指读锁不会占用时间太长导致写锁被饿死的情况。<br></p></div>

<blockquote>
<p>Whether or not a read-write lock will improve performance over the use of a mutual exclusion lock depends on the frequency that the data is read compared to being modified, the duration of the read and write operations, and the contention for the data - that is, the number of threads that will try to read or write the data at the same time. For example, a collection that is initially populated with data and thereafter infrequently modified, while being frequently searched (such as a directory of some kind) is an ideal candidate for the use of a read-write lock. However, if updates become frequent then the data spends most of its time being exclusively locked and there is little, if any increase in concurrency. Further, if the read operations are too short the overhead of the read-write lock implementation (which is inherently more complex than a mutual exclusion lock) can dominate the execution cost, particularly as many read-write lock implementations still serialize all threads through a small section of code. Ultimately, only profiling and measurement will establish whether the use of a read-write lock is suitable for your application.</p>
</blockquote>
<p>使用读写锁时的性能能不能比使用互斥锁高，取决于读写频度的对比、读写操作的耗时以及数据的争用程度（即同一时间内想要读或写数据的线程数有多少）。例如，一个数据初始化并且之后不经常对其进行修改的集合，但是经常对其进行搜索（比如搜索某种目录），那么这样的集合是使用读-写锁的理想对象。但是如果数据更新很频繁，共享数据大部分时间被写锁独占，就算这时候有并发性能上的增强，也是微不足道的。进一步说，如果<strong>读操作所用的时间太短</strong>，则读写锁本身的实现（读写锁本身的实现比互斥锁复杂）开销将成为一个显著的性能影响因素，特别是许多读写锁的实现仍然通过一点段代码将所有线程序列化（<strong>这里不知所云</strong>）。最终，只有通过分析和测量，才能确定应用程序是否适合使用读-写锁。 </p>
<p>这里对读写锁的使用场景进行了简单说明</p>
<blockquote>
<p>Although the basic operation of a read-write lock is straight-forward, there are many policy decisions that an implementation must make, which may affect the effectiveness of the read-write lock in a given application. Examples of these policies include:</p>
<ol>
<li>Determining whether to grant the read lock or the write lock, when both readers and writers are waiting, at the time that a writer releases the write lock. Writer preference is common, as writes are expected to be short and infrequent. Reader preference is less common as it can lead to lengthy delays for a write if the readers are frequent and long-lived as expected. Fair, or “in-order” implementations are also possible.</li>
<li>Determining whether readers that request the read lock while a reader is active and a writer is waiting, are granted the read lock. Preference to the reader can delay the writer indefinitely, while preference to the writer can reduce the potential for concurrency.</li>
<li>Determining whether the locks are reentrant: can a thread with the write lock reacquire it? Can it acquire a read lock while holding the write lock? Is the read lock itself reentrant?</li>
<li>Can the write lock be downgraded to a read lock without allowing an intervening writer? Can a read lock be upgraded to a write lock, in preference to other waiting readers or writers?</li>
</ol>
<p>You should consider all of these things when evaluating the suitability of a given implementation for your application.</p>
</blockquote>
<p>在实现读写锁时，尽管基本操作可以实现的非常直接，但是仍然有很多抉择需要做，它们可能影响到读写锁在应用中的使用效果。这些需要考虑的抉择：</p>
<ol>
<li>抉择：一个写锁被释放时，如果读线程和写线程都在等待的，要授予读锁还是写锁呢。一般情况下回优先授予写锁，因为写操作往往耗时短并且不频繁；优先读锁不上很常见，因为如果读操作很频繁而且耗时的话会导致写操作迟迟得不到执行。当然，公平 或者 按次序 的实现也是可以的。</li>
<li>抉择：当读操作进行时而有一个写操作在等待时，一个新的读锁请求是否可以获取读锁呢。可以获取，会导致写操作执行后延，不可以获取会导致并发下降。</li>
<li>抉择：是否可重入。读锁可以重入吗？写锁可以重入吗？一个拥有写锁的线程可以获取读锁吗？</li>
<li>抉择：一个写锁可以在不允许其他写线程进入的前提下降级为读锁吗？一个读锁的持有线程可以优先于其他正在等待读锁或者写锁的线程升级成写锁吗？</li>
</ol>
<p>为你的应用找到一个合适的读写锁实现，应该考虑上述所有情况。</p>
<h2 id="AQS类"><a href="#AQS类" class="headerlink" title="AQS类"></a>AQS类</h2><h3 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a>总览</h3><blockquote>
<p>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state.Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState(), setState(int) and compareAndSetState(int, int) is tracked with respect to synchronization. </p>
</blockquote>
<p>AQS类是一个框架，它只提供了一些同步的阻塞、排队机制，并且排队时是使用先进先出的队列方式。最重要的一句话 “This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state.” 这个类是被设计来作为一个基类的，言外之意这个类只是基类，功能并不完全，这个基类可以帮助构建很多同步器，而这个基类的特点就是<strong>使用一个原子的int型整数来作为标志位</strong>。</p>
<p>从上面的最后一句可以简单理解为，所有以AQS作为基类的同步器的最终核心都是一个int类型的整数，获取锁、释放锁、排队等待等行为其实都是根据当前此整数的数值进行判断的。而这个整型值各种数值代表什么意义却由子类来定义。</p>
<p>既然这个整型数字如此重要，所以最后提到一句“Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState(), setState(int) and compareAndSetState(int, int) is tracked with respect to synchronization.” 子类在具体实现的时候可以自行维护状态，但是由于AQS里面提供了排队、阻塞的逻辑代码，而这些代码的依据就是那个核心整型数字，而这个核心整型数字的get和set只能使用<code>getState(), setState(int) and compareAndSetState(int, int)</code>这三个方法来操作。所以，只有这三个方法设定和获取的状态值才是同步的。</p>
<div class="note warning"><p>简单点说就是如果你自行定义一个同步类，而且你使用AQS作为基类，这样是允许的，但是这个状态值由于AQS不知道，所有请你自己去实现它的同步吧。再简单点说就是别整那些幺蛾子，要是整的话自己写代码去吧AQS不是万能的。</p></div>

<h3 id="子类如何利用AQS"><a href="#子类如何利用AQS" class="headerlink" title="子类如何利用AQS"></a>子类如何利用AQS</h3><blockquote>
<p>Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class. Class AbstractQueuedSynchronizer does not implement any synchronization interface. Instead it defines methods such as acquireInterruptibly(int) that can be invoked as appropriate by concrete locks and related synchronizers to implement their public methods. </p>
</blockquote>
<p>这是说子类如何去写，其实大部分时候我们不会自己去写。<strong>子类以非公共的内部类形式定义</strong>。还有就是AQS没有实现任何同步相关的接口，比如Lock接口，而是定义了一些方法，这些方法可以在你定义子类的时候去调用他们。</p>
<div class="note info"><p>看出来了吧，AQS其实就是个工具包，它不但提供了 <strong>机制</strong> 还提供了 <strong>方法</strong> 供子类使用，一方面减少代码重复性，一方面方便扩展新的同步器。而且AQS的核心是一个被原子操作的整型值。而从设计的角度看，Doug Lea选择设计一个基类而不是一堆工具类来实现，换句话说AQS没有兄弟姐妹我们不需要在一大堆互相关联的类里面跳来跳去。</p></div>

<p>从上面我们就看到了AQS的作用和整体JUC包中的总体思路。</p>
<h3 id="AQS特性"><a href="#AQS特性" class="headerlink" title="AQS特性"></a>AQS特性</h3><blockquote>
<p>This class supports either or both a default exclusive mode and a shared mode. When acquired in exclusive mode, attempted acquires by other threads cannot succeed. Shared mode acquires by multiple threads may (but need not) succeed. This class does not “understand” these differences except in the mechanical sense that when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as well. Threads waiting in the different modes share the same FIFO queue. Usually, implementation subclasses support only one of these modes, but both can come into play for example in a ReadWriteLock. Subclasses that support only exclusive or only shared modes need not define the methods supporting the unused mode. </p>
</blockquote>
<p>说明了两种锁模式——独占和共享。独占锁只能一个线程占用，而共享锁可能被多个线程同时获得。</p>
<p><em>AQS类不懂这两种锁模式的区别，除了机械的意识到当共享锁被一个线程占用时，另一个想获取它的线程也需要决定是不是也可以获取。</em> 斜体字部分是直接翻译，用人话说就是：“AQS锁在处理两种锁模式的时候几乎没有什么区别，唯一的区别在于获取锁的逻辑，对于独占锁来说，如果一个线程已经占有了锁，那么其他线程肯定需要等待，但是对于共享锁来说，就需要多一个逻辑判断是否可以获取了。”</p>
<p>这句非常重要：“Threads waiting in the different modes share the same FIFO queue.” 就是说AQS只维持了一个队列。关于这一点需要在 <code>ReadWriteLock</code> 里面仔细看看才好，没准是要用两个锁呢。</p>
<p>最后一句话说明了在使用AQS时，子类只需要重写自己需要的那些方法，不需要全部重写。因为AQS类没有抽象方法，但是有几个方法的实现只是简单的抛出 <code>UnsupportedOperationException</code> 异常，如果用到的话就重写，用不到就拉倒呗。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><blockquote>
<p>This class defines a nested AbstractQueuedSynchronizer.ConditionObject class that can be used as a Condition implementation by subclasses supporting exclusive mode for which method isHeldExclusively() reports whether synchronization is exclusively held with respect to the current thread, method release(int) invoked with the current getState() value fully releases this object, and acquire(int), given this saved state value, eventually restores this object to its previous acquired state. No AbstractQueuedSynchronizer method otherwise creates such a condition, so if this constraint cannot be met, do not use it. The behavior of AbstractQueuedSynchronizer.ConditionObject depends of course on the semantics of its synchronizer implementation. </p>
</blockquote>
<p>这一段详细解释一下，但是需要结合 <code>ConditionObject</code> 部分的注释才能说清楚。第一句话非常的长 <code>for which</code> 后面跟了一个特别长的从句，翻译成中文的话大概要翻译成3句话，第一句，AQS定义了一个嵌套的内部类 <code>ConditionObject</code> ，它可以作为 <code>Condition</code> 的一个现成的实现被子类使用；第二句， <code>ConditionObject</code> 可以帮助实现<strong>独占模式</strong>；第三句，方法 <code>isHeldExclusively()</code> 可以报告当前线程是否持有独占锁，方法 <code>release(getState())</code> 可以完全释放此对象（指ConditionObject），而如果你把刚刚 <code>getState()</code> 的值保持下来然后传入 <code>acquire(int)</code> 里面去，就可以恢复占有的状态。第三句话是对独占模式的一个解释，忽略掉它可以更清楚的了解一整句的真正意思。</p>
<blockquote>
<p>This class provides inspection, instrumentation, and monitoring methods for the internal queue, as well as similar methods for condition objects. These can be exported as desired into classes using an AbstractQueuedSynchronizer for their synchronization mechanics. </p>
</blockquote>
<p>这段话几乎没什么用，<code>AbstractQueuedSynchronizer</code> 提供了对队列和 <code>condition objects</code> 的一些维护方法，你可以根据需要使用AQS来提供这些同步机制。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><blockquote>
<p>Serialization of this class stores only the underlying atomic integer maintaining state, so deserialized objects have empty thread queues. Typical subclasses requiring serializability will define a readObject method that restores this to a known initial state upon deserialization.</p>
</blockquote>
<p>序列化方面的问题（一般JAVA官方API的注释最后一段都会提到这个），序列化时只会存储维护状态的基础原子整数，而线程队列不会被存储（其实存储也没用啊，因为线程的信息是不同的OS无法相同的，就算同一个OS不同时间也无法相同，就算相同了也没有实际意义）。如果子类有序列化的需求，需要重写 <code>readObject(ObjectInputStream)</code> 方法，该方法在反序列化时将此对象恢复到某个已知初始状态。这里我有一点不懂，序列化一个锁有什么用呢，是为了存储当前系统的运行状态，重启时恢复？</p>
<h3 id="还没完，AQS的排队机制"><a href="#还没完，AQS的排队机制" class="headerlink" title="还没完，AQS的排队机制"></a>还没完，AQS的排队机制</h3><p>排队机制由 <code>Node</code> 内部类来控制。</p>
<blockquote>
<p>Wait queue node class. </p>
<p>The wait queue is a variant of a “CLH” (Craig, Landin, and Hagersten) lock queue. CLH locks are normally used for spinlocks. We instead use them for blocking synchronizers, but use the same basic tactic of holding some of the control information about a thread in the predecessor of its node. A “status” field in each node keeps track of whether a thread should block. A node is signalled when its predecessor releases. Each node of the queue otherwise serves as a specific-notification-style monitor holding a single waiting thread. The status field does NOT control whether threads are granted locks etc though. A thread may try to acquire if it is first in the queue. But being first does not guarantee success; it only gives the right to contend. So the currently released contender thread may need to rewait. </p>
</blockquote>
<p>这个内部类是CLH锁的队列的变种。CLH锁通常用于自旋锁，不过我们把它用在阻塞同步器上，但是我们使用了与CLH一样的特性——在前驱节点中保存线程的控制信息。在每一个节点中保持有一个“状态”字段，它代表线程是否应该阻塞。当前驱节点释放锁时它会通知后继节点。每一个节点充当一个监视器，并且与一个等待锁的线程相关联。“状态”字段<strong>不</strong>标示线程是否被赋予了锁。当一个线程处于队列的第一个时，它就会尝试去获取锁，但是不一定会成功，它只是有竞争锁的权利而已，所以它可能再次等待。</p>
<blockquote>
<p>To enqueue into a CLH lock, you atomically splice it in as new tail. To dequeue, you just set the head field. </p>
</blockquote>
<p>对CLH锁来说，入队的节点原子地被连接到尾巴上，对于出队的节点，则是头节点。（意思就是FIFO）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     +------+  prev +-----+       +-----+</span><br><span class="line">head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">     +------+       +-----+       +-----+</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Insertion into a CLH queue requires only a single atomic operation on “tail”, so there is a simple atomic point of demarcation from unqueued to queued. Similarly, dequeing involves only updating the “head”. However, it takes a bit more work for nodes to determine who their successors are, in part to deal with possible cancellation due to timeouts and interrupts. </p>
</blockquote>
<p>把一个节点入队到CLH队列中，只需要在tail上做一个原子操作，所以一个节点入队还是没有入队在于有没有进行原子操作。相似的，出队操作也只需要更新head就可以了。但是这需要做一点额外的工作——一个是需要判断谁是它的接班人，另外一个是需要处理超时和中断。</p>
<blockquote>
<p>The “prev” links (not used in original CLH locks), are mainly needed to handle cancellation. If a node is cancelled, its successor is (normally) relinked to a non-cancelled predecessor. For explanation of similar mechanics in the case of spin locks, see the papers by Scott and Scherer at <a href="http://www.cs.rochester.edu/u/scott/synchronization/" target="_blank" rel="external">http://www.cs.rochester.edu/u/scott/synchronization/</a></p>
</blockquote>
<p>Node类中的 <code>prev</code> 引用（在原始的CLH锁中没有使用，注意了，虽然上图画了prev，其实CLH锁的Node实现往往是不需要前驱节点的引用的，只需要tail引用就可以，所以这里才特别说明CLH没有使用），主要是用来处理取消操作的。如果一个节点被取消（指不再获取锁），它的下一节点会从新连接到一个没有被取消的前驱节点上。更多自旋锁的类似机制请看Scott和Scherer发布在资料请看<a href="http://www.cs.rochester.edu/u/scott/synchronization/" target="_blank" rel="external">http://www.cs.rochester.edu/u/scott/synchronization/</a>的文章。</p>
<blockquote>
<p>We also use “next” links to implement blocking mechanics. The thread id for each node is kept in its own node, so a predecessor signals the next node to wake up by traversing next link to determine which thread it is. Determination of successor must avoid races with newly queued nodes to set the “next” fields of their predecessors. This is solved when necessary by checking backwards from the atomically updated “tail” when a node’s successor appears to be null. (Or, said differently, the next-links are an optimization so that we don’t usually need a backward scan.) </p>
</blockquote>
<p>为了实现阻塞机制我们还使用了 <code>next</code> 引用。因为每个线程的id被保存在它的自己的节点上，所以前驱节点对应的线程想唤醒下一个节点的时候需要 <code>next</code> 引用知道唤醒哪个线程。决定谁是后继节点的时候必须避免新入队的节点的竞争，我们通过从tail开始向前遍历来找节点（这样只找到先前早就入队的，避免了新入队的节点竞争）的方式解决这个问题。（或者，这段话可以这样说， <code>next</code> 引用可以避免我们的遍历操作）。</p>
<blockquote>
<p>Cancellation introduces some conservatism to the basic algorithms. Since we must poll for cancellation of other nodes, we can miss noticing whether a cancelled node is ahead or behind us. This is dealt with by always unparking successors upon cancellation, allowing them to stabilize on a new predecessor, unless we can identify an uncancelled predecessor who will carry this responsibility. </p>
</blockquote>
<p>取消操作会给基础算法带来一些保守性。由于一个节点必须轮询其他节点是否取消了，所有可以会错过发现取消的节点是在本节点之前还是之后。这个问题一般这样解决，当本节点发生取消的时候不阻塞后继节点，允许它一直运行知道找到一个未取消的前驱节点。</p>
<blockquote>
<p>CLH queues need a dummy header node to get started. But we don’t create them on construction, because it would be wasted effort if there is never contention. Instead, the node is constructed and head and tail pointers are set upon first contention. </p>
</blockquote>
<p>CLH锁队列需要一个假的头节点，而我们不建立假的头节点，因为如果根本没有锁竞争的话这样做会浪费资源。相反，在第一次发送锁竞争的时候才会创建Node，并设定head和tail引用。</p>
<blockquote>
<p>Threads waiting on Conditions use the same nodes, but use an additional link. Conditions only need to link nodes in simple (non-concurrent) linked queues because they are only accessed when exclusively held. Upon await, a node is inserted into a condition queue. Upon signal, the node is transferred to the main queue. A special value of status field is used to mark which queue a node is on. </p>
</blockquote>
<p>等待“条件”的线程跟等待锁的时候一样都使用同一个节点，但是我们会增加新的引用。“条件对象”只需要把节点们连接到简单队列（非线程安全的）中，因为他们只有在独占状态时才会被访问。等待条件的时候，一个节点被添加到条件队列中。条件满足的时候，节点被转移到锁队列中。有一个特殊的状态字段标记着节点处于哪种队列中。</p>
<blockquote>
<p>Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill Scherer and Michael Scott, along with members of JSR-166 expert group, for helpful ideas, discussions, and critiques on the design of this class.</p>
</blockquote>
<p>感谢父老乡亲。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note default"><p>锁是控制多线程对共享资源的访问权限的一种机制。</p></div>

<p>我们平时对锁的需求除了<strong>临界区</strong>执行线程互相排斥（互斥锁）、控制信号量等需求之外，还需要线程间进行协调工作（注1），也就是说，<strong>线程间有竞争关系时需要锁（Lock），线程间需要协调时不仅需要获得锁还需要满足条件（Condition）</strong>,条件（Condition）是锁（Lock）的附属品，一个锁可以有多个条件，具体的需求可能只需要锁或者只需要条件也可能都需要用到。各种锁实现从不同程度上支持Lock和Condition。那具体它们是怎么组织实现这两个接口的呢？</p>
<p>答案是AQS，AQS内部定义了一个内部类ConditionObject实现了Condition接口，还提供了一些与锁相关的方法，理论上讲，我们只要继承AQS实现一个子类，并且让这个类实现Lock接口，那么这个类就同时具有了Lock和Condition的特性。不过为了更好的灵活性API中并不建议我们这样做，而是利用代理模式。</p>
<p>继承AQS定义一个具有了Condition特性的类Sync，然后定义另外一个实现Lock接口的锁实现类，在锁实现类中持有一个Sync实例的引用，以代理模式的写法利用一个内部引用完成各种功能。</p>
<div class="note warning"><p>为什么如此实现：锁往往有公平锁和非公平锁之分，往往一个锁实现类（比如ReetrantLock）其实内部存在两个锁实现，这两个实现分别是公平锁和非公平锁，同一时间只有一个有效，而控制这个的只是构造函数的一个boolean参数，这样使得API更加简洁易用。</p></div>

<p><em>注1：什么是线程间的协调工作呢，线程之间虽然大多数情况下可以是并行的，但是某些情况下应业务需要必须保证有序执行，比如分库分表的查询最后的汇总线程必须等待所有查询线程都结束才能执行，类似于这种的业务需求导致我们需要线程之间互相协调。而这就不同于普通的互斥锁，也不同于共享锁，而是一种特定条件，属于特定线程间的协调问题。</em></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blogs/tags/并发/" rel="tag"><i class="fa fa-tag"></i> 并发</a>
          
            <a href="/blogs/tags/J-U-C/" rel="tag"><i class="fa fa-tag"></i> J.U.C</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blogs/2017/12/21/操作系统是如何启动的/" rel="next" title="操作系统是如何启动的">
                <i class="fa fa-chevron-left"></i> 操作系统是如何启动的
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blogs/2018/01/09/Java并发API_利用AQS实现锁/" rel="prev" title="java并发个人总结——使用AQS实现简单锁">
                java并发个人总结——使用AQS实现简单锁 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://ozhp30d7a.bkt.clouddn.com/index/header/shadowmoon-valley-1366x768.jpg"
                alt="Walker" />
            
              <p class="site-author-name" itemprop="name">Walker</p>
              <p class="site-description motion-element" itemprop="description">To be or not to be that's a question</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blogs/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blogs/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blogs/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#j-u-c-locks和早期锁对比"><span class="nav-number">2.</span> <span class="nav-text">j.u.c.locks和早期锁对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock接口和synchronized"><span class="nav-number">3.</span> <span class="nav-text">Lock接口和synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock的作用"><span class="nav-number">3.1.</span> <span class="nav-text">Lock的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与synchronized对比"><span class="nav-number">3.2.</span> <span class="nav-text">与synchronized对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#灵活的代价"><span class="nav-number">3.3.</span> <span class="nav-text">灵活的代价</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock实现可能提供的额外功能"><span class="nav-number">3.4.</span> <span class="nav-text">Lock实现可能提供的额外功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切勿这样使用"><span class="nav-number">3.5.</span> <span class="nav-text">切勿这样使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存同步"><span class="nav-number">3.6.</span> <span class="nav-text">内存同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现Lock接口时的注意事项"><span class="nav-number">3.7.</span> <span class="nav-text">实现Lock接口时的注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition接口"><span class="nav-number">4.</span> <span class="nav-text">Condition接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition的作用"><span class="nav-number">4.1.</span> <span class="nav-text">Condition的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition的使用"><span class="nav-number">4.2.</span> <span class="nav-text">Condition的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切勿这种方式使用"><span class="nav-number">4.3.</span> <span class="nav-text">切勿这种方式使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReadWriteLock接口"><span class="nav-number">5.</span> <span class="nav-text">ReadWriteLock接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总览"><span class="nav-number">5.1.</span> <span class="nav-text">总览</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS类"><span class="nav-number">6.</span> <span class="nav-text">AQS类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总览-1"><span class="nav-number">6.1.</span> <span class="nav-text">总览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子类如何利用AQS"><span class="nav-number">6.2.</span> <span class="nav-text">子类如何利用AQS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS特性"><span class="nav-number">6.3.</span> <span class="nav-text">AQS特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类"><span class="nav-number">6.4.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列化"><span class="nav-number">6.5.</span> <span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#还没完，AQS的排队机制"><span class="nav-number">6.6.</span> <span class="nav-text">还没完，AQS的排队机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Walker</span>

  
</div>


  <!--<div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>-->




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/blogs/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/blogs/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/blogs/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/blogs/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blogs/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blogs/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/blogs/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/blogs/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/blogs/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/blogs/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/blogs/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/blogs/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/blogs/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/blogs/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
