<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blogs/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/blogs/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blogs/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/blogs/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="I/O,系统调用," />










<meta name="description" content="关于Unix I/O模型的理解 《Unix网络编程 卷一》：POSIX规范把这两个术语定义如下：  同步I/O操作（synchronous I/O Operation）导致请求进程阻塞，直到I/O操作完成； 异步I/O操作（asynchronous I/O Operation）不导致请求进程阻塞。   系统调用 在电脑中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间">
<meta name="keywords" content="I&#x2F;O,系统调用">
<meta property="og:type" content="article">
<meta property="og:title" content="我的角度看Unix IO模型">
<meta property="og:url" content="https://wrecksoul.github.io/blogs/2017/12/07/我的角度看Unix IO模型/index.html">
<meta property="og:site_name" content="Walker&#39;s blogs">
<meta property="og:description" content="关于Unix I/O模型的理解 《Unix网络编程 卷一》：POSIX规范把这两个术语定义如下：  同步I/O操作（synchronous I/O Operation）导致请求进程阻塞，直到I/O操作完成； 异步I/O操作（asynchronous I/O Operation）不导致请求进程阻塞。   系统调用 在电脑中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/zuseshiio.png">
<meta property="og:image" content="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/feizuseshiio.png">
<meta property="og:image" content="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/iofuyong.png">
<meta property="og:image" content="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/xinhaoqudongio.png">
<meta property="og:image" content="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/yibuio.png">
<meta property="og:image" content="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/5zhongmoxing.png">
<meta property="og:updated_time" content="2018-01-25T09:10:39.256Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的角度看Unix IO模型">
<meta name="twitter:description" content="关于Unix I/O模型的理解 《Unix网络编程 卷一》：POSIX规范把这两个术语定义如下：  同步I/O操作（synchronous I/O Operation）导致请求进程阻塞，直到I/O操作完成； 异步I/O操作（asynchronous I/O Operation）不导致请求进程阻塞。   系统调用 在电脑中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间">
<meta name="twitter:image" content="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/zuseshiio.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blogs/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wrecksoul.github.io/blogs/2017/12/07/我的角度看Unix IO模型/"/>





  <title>我的角度看Unix IO模型 | Walker's blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blogs/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Walker's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blogs/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blogs/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blogs/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blogs/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blogs/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wrecksoul.github.io/blogs/blogs/2017/12/07/我的角度看Unix IO模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Walker">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ozhp30d7a.bkt.clouddn.com/index/header/shadowmoon-valley-1366x768.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Walker's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">我的角度看Unix IO模型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-07T09:27:57+08:00">
                2017-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/I-O/" itemprop="url" rel="index">
                    <span itemprop="name">I/O</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="关于Unix-I-O模型的理解"><a href="#关于Unix-I-O模型的理解" class="headerlink" title="关于Unix I/O模型的理解"></a>关于Unix I/O模型的理解</h1><blockquote>
<p>《Unix网络编程 卷一》：<br>POSIX规范把这两个术语定义如下：</p>
<ul>
<li>同步I/O操作（synchronous I/O Operation）导致请求进程阻塞，直到I/O操作完成；</li>
<li>异步I/O操作（asynchronous I/O Operation）不导致请求进程阻塞。</li>
</ul>
</blockquote>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><blockquote>
<p>在电脑中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。</p>
</blockquote>
<p>以上是维基百科的定义。<br><a id="more"></a></p>
<p>计算机中，<code>硬件</code>是躯体、<code>软件</code>是灵魂，我们所编写程序当设计到网络和文件I/O的时候，一定少不了硬件来帮忙，而硬件资源不是直接可以调用的，操作系统充当媒介，系统调用就是操作系统提供给上层应用级程序的接口。有了这个中间层，不仅提高了安全防护，使上层的应用开发人员不能为所欲为，也简化应用开发的工作。</p>
<p><em>当然，你翻阅更多的资料，比如恐龙书，会发现系统调用并不是直接被上层程序使用的，而是在对外提供应用程序接口（API）的形式提供，可以简单的理解为应用程序接口是系统调用的一层包装，但是这些不影响我们理解和编程，人们往往直接说系统调用。详情见《操作系统概念 第七版》2.3节系统调用。</em></p>
<p>系统调用时cpu或者说进行系统调用的线程进入内核态，拥有了更高的权限从而可以执行与硬件交互的驱动程序代码，<em>这个是操作系统的一种自我保护机制，不了解的话请自行google</em>。进入内核态之后，线程将切换用户栈到内核栈。这个时候进行的函数调用可能会触发硬件的一系列变化，比如网络I/O相关的系统调用会导致网卡驱动程序相关代码的执行，从而把网卡内部的缓存信息传输到内核的缓存区域，而后可能又会触发新的系统调用，从内核缓存区域将信息传输到用户缓存区域，数据到达用户缓存区域后，应用程序代码才可以访问。</p>
<blockquote>
<p>内核栈是系统运行在内核态的时候使用的栈，用户栈是系统运行在用户态时候使用的栈。当进程由于中断进入内核态时，系统会把一些用户态的数据信息保存到内核栈中，当返回到用户态时，取出内核栈中得信息恢复出来，返回到程序原来执行的地方。用户栈就是进程在用户空间时创建的栈，比如一般的函数调用，将会用到用户栈。</p>
<p>至于为什么一个线程为什么同时有两个栈，还是因为考虑到安全的问题，这是操作系统的一种设计，详情请自行google。</p>
</blockquote>
<h2 id="线程阻塞"><a href="#线程阻塞" class="headerlink" title="线程阻塞"></a>线程阻塞</h2><p>各种I/O模型的区分其实跟I/O操作导致的线程阻塞有非常大的关系，先弄清楚这个问题再说I/O模型不迟。</p>
<p>某个线程进行系统调用是为了完成I/O操作，比如接发某个Socket通道的消息。而<strong>I/O需要占用CPU吗？</strong>，这个问题非常宽泛，因为I/O操作有很多种。但是这个问题的结论却很重要。</p>
<p>想象一下，假设I/O操作需要CPU完成，当我们的线程开始执行，代码中的逻辑是想要接收网络中的数据，那此时调用某个java方法，比如<code>read(byte[])</code>，这个方法的底层肯定去进行系统调用，前面说了系统调用只是操作系统的一种自我保护方式，根本上讲还是方法调用，那么此时线程依旧在执行，根据前面的假设，CPU来完成I/O操作的话，那线程肯定不能阻塞而需要继续执行I/O操作直到完成为止，即使此时CPU启动另外一个线程来执行这个操作，那原线程也还是需要等待结果，理论上讲原线程可以并行的执行其他操作，但是就CPU来说没有太大实际意义。</p>
<p>但是如果I/O操作不需要CPU完成的话，情况就大大不同了。线程执行到系统调用，此时操作系统使用通道处理机（通道处理机是什么呢。它是一个独立于cpu的外围设备，自己就有少量的存储空间，可以独立完成输入输出操作。）或者其他的什么东西无所谓啦，代替CPU执行I/O操作，此时的线程可以休息了，线程进入阻塞状态，不会和其他线程争用CPU时间片，直到I/O操作完成，完成时CPU收到一个中断，唤醒阻塞的线程，此时数据已经写入完成或者接收完成了。</p>
<h3 id="I-O操作谁来执行"><a href="#I-O操作谁来执行" class="headerlink" title="I/O操作谁来执行"></a>I/O操作谁来执行</h3><p>但是到底<a href="https://www.zhihu.com/question/27734728" target="_blank" rel="external">I/O会一直占有CPU吗？（知乎）</a>通过总结这里面的回答，大致可以得到结论：</p>
<ol>
<li>I/O操作可以不使用CPU；</li>
<li>I/O操作可能占有CPU，但是占用的方式往往是执行一些I/O操作相关的其他事件，比如合并、排序等性能提升策略；</li>
<li>不同的操作系统不同的处理方式。比如有一个回答就提出windows中<a href="http://blog.stephencleary.com/2013/11/there-is-no-thread.html" target="_blank" rel="external">There is no thread</a></li>
</ol>
<p>最后可以得出结论，I/O操作一般不会由当前请求I/O的线程完成，所谓阻塞，是指当前线程等待其他部件完成任务时不占用CPU时间片也不竞争时间片，最后通过中断的方式CPU获取到完成信号解除线程的阻塞状态。所以阻塞是在节约系统资源，而且由于需要的结果没有拿到，线程阻塞也是理所应当的事情。</p>
<h2 id="理解Unix-5种-I-O模型"><a href="#理解Unix-5种-I-O模型" class="headerlink" title="理解Unix 5种 I/O模型"></a>理解Unix 5种 I/O模型</h2><p>根据上一节中提到的情景：</p>
<blockquote>
<p>线程执行到系统调用，此时操作系统使用通道处理机（通道处理机是什么呢。它是一个独立于cpu的外围设备，自己就有少量的存储空间，可以独立完成输入输出操作。）或者其他的什么东西无所谓啦，代替CPU执行I/O操作，此时的线程可以休息了，线程进入阻塞状态，不会和其他线程争用CPU时间片，直到I/O操作完成，CPU收到一个中断去唤醒阻塞的线程，线程从新开始执行，此时数据已经写入完成或者接受完成了。</p>
</blockquote>
<p>这种情况下是线程阻塞着等待I/O操作完成，被称为阻塞I/O模型。想到这其实我觉得这种模型挺不错的，既然线程不需要工作，那就赶紧节省资源让出CPU啊，进入阻塞不是理所应当的吗？但是实际的工程中遇到了一些问题，导致出现了新的需求，从而导致了其他模型的诞生。</p>
<h3 id="阻塞式io："><a href="#阻塞式io：" class="headerlink" title="阻塞式io："></a>阻塞式io：</h3><p><img src="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/zuseshiio.png" alt=""><br>如上图所示，阻塞式I/O模型从开始进行系统调用就一直阻塞，就像我在系统调用一节提到的。</p>
<p>程序需要从UDP协议接收几个字节的信息，调用如图所示的<code>recvfrom</code>函数，当进程因系统调用而陷入内核态之前，进程所使用的堆栈要从用户栈转到内核栈，先把用户态堆栈的地址保存在内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换，完全一系列的安全检查后，进程陷入内核态。</p>
<p>进入内核态后，进程可以访问网卡驱动程序等等内核空间才可执行的内容，按照《Unix网络编程卷一》的说法，从系统调用开始这个线程就开始进入阻塞状态了，后续的操作不需要此线程参与执行，直到数据报到达并且被复制到应用程序的缓冲区中才返回，或者在系统调用被信号中断的情况下才返回。在线程阻塞期间会导致有一些硬件操作，所谓的等待数据报准备好就是等待网卡中的数据进入主存（内核空间），当数据报准备好时——需要把数据报从主存的内核空间复制到计算机主存的用户空间的缓存区（应用程序的缓冲区），发出中断通知CPU I/O操作完成，线程不再处于阻塞状态，进入就绪状态等待调度。</p>
<h3 id="非阻塞式io："><a href="#非阻塞式io：" class="headerlink" title="非阻塞式io："></a>非阻塞式io：</h3><p><img src="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/feizuseshiio.png" alt=""></p>
<p>虽然名字上叫做非阻塞I/O，其实也是需要阻塞，不同之处在于前半段不会阻塞，但是后半段还是会阻塞的。</p>
<blockquote>
<p>进程把一个套接字设置成非阻塞的，就是在通知内核，当所请求的I/O操作非得把本进程投入睡眠才能完成时，不用把本进程投入睡眠，而是返回一个错误。</p>
</blockquote>
<p>具体细节我们不必深究，只需要知道由于网络连接所使用的连接被预先设置成非阻塞的了，导致我们进行<code>recvfrom</code>系统调用时，第一阶段数据报没有准备好时，进程没有进入阻塞状态，而是立即收到一个返回结果——EWOULDBLOCK错误。直到数据报准备好——进入了主存内核空间区域，才开始复制数据到用户空间。主要此时复制数据到用户空间肯定还是阻塞的。</p>
<p>这种模型的很少用。前半段的轮询会浪费大量的CPU时间。</p>
<div class="note danger"><p>java.nio包，本来叫做new io，但是由于很多年过去了不再new了，被 很多人叫做no-blocking io即非阻塞I/O，这是因为这个万恶的称呼，导致很多人误解。其实此处的非阻塞I/O模式跟java.nio包没有关系。而且java.nio包所实现的I/O也不是非阻塞I/O模型，而是后面要提到的I/O复用模型。</p></div>

<h3 id="io复用："><a href="#io复用：" class="headerlink" title="io复用："></a>io复用：</h3><p><img src="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/iofuyong.png" alt=""><br>使用两个系统调用，第一个检测是否有数据报准备好，第二个还是我们的老朋友<code>recvfrom</code>负责复制数据报。看起来跟阻塞I/O没有区别，而且还增加了一个系统调用。</p>
<p>但是这种模式下，线程不再阻塞于真正的I/O操作上，而是阻塞select或者poll这样的数据报检查操作上，而这个操作可以同时检查多种状态，并且可以检查多个套接字的状态，这就是所谓的复用，从中文名字上很难理解复用了什么。<strong>但是它有另一个中文名称——事件驱动</strong>，比如数据报准备好了，就是一个事件，一个select系统调用可以同时监控多个套接字通道的多个事件，这就是所谓的复用，<strong>复用的是系统调用，或者说复用的是调用这个函数的线程。复用的地方在于监控多个套接字通道的多种事件</strong>。</p>
<p>I/O 复用模型，它的思想跟非阻塞I/O相似，都是希望线程在等待数据报的时候不阻塞，但是不同点在于，它利用的是一个其他函数来实现此调用，更重要的是，此函数可以检测多个事件，而不同于阻塞I/O中的单个事件。</p>
<h4 id="非阻塞I-O和I-O复用的思路不同"><a href="#非阻塞I-O和I-O复用的思路不同" class="headerlink" title="非阻塞I/O和I/O复用的思路不同"></a>非阻塞I/O和I/O复用的思路不同</h4><p>阻塞I/O模型就上面讲到的情景看起来没有什么问题，这是因为，此场景只考虑了一个I/O请求，而如果I/O请求很多，程序需要同时处理多个文件描述符的时候阻塞I/O模型就带来了一系列问题。</p>
<p>表面看来阻塞I/O的问题是线程阻塞导致的，但是实质上是由于<strong>执行的顺序是线性</strong>的而导致效率低下。</p>
<p>单从效果上来看，在解决阻塞I/O模型的问题上，非阻塞I/O和I/O多路复用模型思路不同：</p>
<ol>
<li>非阻塞I/O模型仅仅改动了阻塞I/O模型中线程阻塞这样一个特点；</li>
<li>I/O复用模型则解决了I/O处理中的<strong>线性的执行顺序</strong>问题。</li>
</ol>
<p>非阻塞I/O模型仅仅解决了不阻塞这个问题，却没有解决实质。<em>当然非阻塞I/O有它的用武之地，这里并不是说非阻塞I/O设计有问题。</em></p>
<h4 id="问题在于执行顺序"><a href="#问题在于执行顺序" class="headerlink" title="问题在于执行顺序"></a>问题在于执行顺序</h4><p>在实际编程中，对于多个文件描述符，阻塞I/O模型由于线程会进入阻塞状态而无法处理其他文件描述符的任何响应。</p>
<p>阻塞I/O模型中，<strong>单线程</strong>执行顺序是这样的：</p>
<blockquote>
<p>发起1号I/O请求1 —-》 等待1号I/O请求1—–》 接收1号I/O请求 —》发起2号I/O请求。。。</p>
</blockquote>
<p>为了说明效率到底低在哪可以假象一个场景：</p>
<p>网购时，如果你不是连续的多次下单等它们到达（不同订单同时或不同时），而是下一次单，等这一单的东西到达你手里，你才下第二单，那这个购买效率肯定是相当低下的。对比上面阻塞I/O模型在单线程中的执行顺序，其实道理上是一样的。</p>
<p>CPU的执行速度之于I/O设备的执行速度，就好比你用手机下单并付款的速度之于物流的速度。所以这中间浪费的时间跟后一种网购方式一样——低效。</p>
<p>当然这是有解决办法的：<del>多叫几个人一人下一单</del> 多线程执行 。阻塞I/O常常用于多线程情况下，由多个线程每个线程负责一个文件描述符。但是这样带来的问题是，当文件描述符过多时浪费了太多了线程资源——线程都有空闲期（指阻塞状态）没有得到充分的利用。这种方式一定程度上解决了低效率的问题，但是还是没有本质上解决，因为每个线程在执行的时候还是会浪费很多时间等待，而不能处理后续任务。</p>
<p>还是之前的场景，如果你找了爸、妈、女朋友三个人一起下单，当你们一共有4个订单的时候，可以轻松解决问题，但如果有5个订单，你们就要等到4个订单中最早的那个到达你手中之后，比如是你女朋友下的单最早到，这时候其他人继续等待，由你女朋友下第5单。你可能说我要是有多个女朋友不就可以多下很多单了吗？但是现实就是现实，就像你无法有很多个女朋友一样，你的机器也不可能有太多的线程。</p>
<p>那么解决问题的实质是什么呢？如何压缩这些空闲期呢？</p>
<p>I/O复用模型中，一个函数如<code>select</code>只做一件事情，就是 <del>跟你女朋友一样就会下单</del> 查看数据报是否准备好，更重要的是它可以同时监控多个文件描述符，在实际使用中，可以由一个线程调用这个函数达到监控多个文件描述符的目的。</p>
<h4 id="I-O复用的阻塞"><a href="#I-O复用的阻塞" class="headerlink" title="I/O复用的阻塞"></a>I/O复用的阻塞</h4><p>简单的说，I/O复用模型也是阻塞的，但是它可以 <del>一次下好几个单子</del> 监控多个文件描述符上，当有任何一个文件描述符可用时，它就会发现并处理它。</p>
<p>当然了如果在处理一个文件描述符返回的数据报时，那它就没法监控文件描述符的状态了，只有当它完成处理才能再回去监控，所以说，这里还是有优化的空间，优化的方式跟阻塞I/O模型使用多线程的方式一样，使用多线程有的负责监控有的负责执行，netty框架就做这样的一些优化，使用的是多个线程池分工协作。</p>
<p>关于上一段说的问题，举一个形象的例子，还是网购的例子。</p>
<p>终于你意识到可以同时下很多单而不用等货到才下后一单这个问题。此时你一个人下5个订单，这之后你就不厅的观察你们家门口是不是有快递了（select轮询），过了一段时间你发现1号订单的货已经到了门口了（事件出现），此时你开始拆箱验货甚至开始试衣服了（处理事件），但是这个时候的你根本顾不上门口是不是有其他快递也到了（总不能穿着女仆装出现在门口吧，偷笑）。终于你等你验完货之后就可以继续看家门口是不是有新快递出现了（继续select轮询）。</p>
<p>在上面的例子中是你一个人，也就是单线程处理的，但是即使是一个人，可能比你们家全员出动下订单也没有慢多少，甚至在某些情况下还更快速。但是还有一些可以优化的点。想象一下如果你下了太多单子，你需要不停的收快递、验货、试衣服，终究会有极限的。人多力量大嘛，多几个人就可以更快了。此时有两种策略可以选择：</p>
<ol>
<li>多叫几个人你们分别下单，自己下自己的，验货试衣服也是自己试自己的，完全独立开互不干涉。</li>
<li>由你负责盯着快递到没到，到了就通知一声，其他人负责下单，谁的下的单谁就来验货试衣服。</li>
</ol>
<p>第一种策略可以提高吞吐量但是过于独立，优点是实现简单。只需要多个线程复用任务就可以了。第二种策略分工协作，实现上稍微复杂一点，但是可控性高，任何一个工作可以独立的加人手，如果验货环节太费时就让更多的人来验货，如果订单太多看不过来就加人手分类轮询。</p>
<p>据我所知netty就是使用后一种策略，当然它的实现更加复杂，但是它有一个重要策略跟这里一致，就是谁下的单谁验货（netty5），这样可以非常好的保证线程安全。</p>
<h4 id="I-O复用小结"><a href="#I-O复用小结" class="headerlink" title="I/O复用小结"></a>I/O复用小结</h4><p>从上面可以看出，I/O复用主要解决的是I/O操作频繁带来的问题，并不是说阻塞I/O就是万恶的旧社会，就应该被抛弃。</p>
<p>当你的程序同一时间只需要进行一次I/O操作的时候，I/O复用并不会给你带来什么好处，反而让你的程序变得又臭又长，而阻塞I/O模型由于它模型简单粗暴、效率上也没有任何下降是一个非常不错的选择。相反如果你的系统使用的连接很多而且追求高吞吐量，那I/O复用模型是不二选择。</p>
<h3 id="信号驱动io："><a href="#信号驱动io：" class="headerlink" title="信号驱动io："></a>信号驱动io：</h3><p><img src="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/xinhaoqudongio.png" alt=""></p>
<p>信号驱动I/O模型中，套接字被开启信号驱动式I/O功能，通过系统调用<code>sigaction</code>安装一个信号处理函数，这个系统调用立即返回，并且被设置的函数将在稍后被一个SIGIO信号触发。当数据报没有准备好的时候，由于之前的系统调用已经返回了结果，所以用户进程没有阻塞，也不需要像非阻塞I/O模型中一样轮询检测；当数据报准备好的时候，SIGIO信号产生，信号处理函数触发，函数内部调用<code>recvfrom</code>读取数据报。后面的情况跟前面是一样的，就是继续系统调用复制数据到用户空间缓存区。</p>
<p>这个模型跟I/O复用模型非常相似，不同点就是系统调用层面上的<strong>实现</strong>不同：</p>
<ol>
<li>监控的方式不同，线程不用阻塞在一个函数上等待数据报准备好。</li>
<li>通知的方式不同，信号驱动通过SIGIO信号</li>
</ol>
<p>看上去这种方式比I/O复用模型更加美好。但是为啥没有I/O复用模型流行呢？</p>
<h4 id="信号驱动-VS-I-O复用"><a href="#信号驱动-VS-I-O复用" class="headerlink" title="信号驱动 VS I/O复用"></a>信号驱动 VS I/O复用</h4><p>I/O复用模型由于需要监控多个文件描述符，肯定是需要不断轮询多个文件描述符的，而信号驱动模型则避开了这种消耗。</p>
<p>不过，相比select()和poll()，还有一个epoll，Linux专有的epoll（2.6+内核），同时检查大量文件描述符时，能提供更好的性能。结果是由于epoll的存在，信号驱动I/O没有取得动实质上的胜利。</p>
<ol>
<li>系统调用select()和poll()在UNIX系统中已经存在了很长的时间，同其他技术相比，它们的优势在于可移植性，而缺点是当同时检查大量文件描述符时性能延展性不好。 </li>
<li>epoll的优点是可以高效地检查大量的文件描述符，但缺点是它是专属于Linux系统的API。 </li>
<li>信号驱动I/O也可以支持检查大量的文件描述符，但是epoll有一些其没有的优点：避免了信号处理的复杂性；可以指定想要检查的事件类型（读就绪或写就绪）；可以选择水平触发或边缘触发来通知进程（Libevent库）；提供了检查文件描述符I/O事件的抽象等等。</li>
</ol>
<p>简单点说，就是Linux平台的epoll这种技术使得信号驱动没有取得优势，而Linux在服务器领域的地位难以撼动，从而使得I/O复用模型在实际编程中比信号驱动要受欢迎的多。</p>
<p>本小节参考：<a href="https://www.2cto.com/kf/201608/541317.html" target="_blank" rel="external">https://www.2cto.com/kf/201608/541317.html</a></p>
<h3 id="异步io："><a href="#异步io：" class="headerlink" title="异步io："></a>异步io：</h3><p><img src="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/yibuio.png" alt=""></p>
<blockquote>
<p>《Unix网络编程卷一》原文：<br>异步I/O（asynchronous I/O）由POSIX规范定义，演变成当前POSIX规范的各种早期标准定义的实时函数中存在的差异已经取得一致。一般地说，这些函数的工作机制是：告知内核启动某个动作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。</p>
</blockquote>
<p>从上面这句话可以看出，对于某个I/O模型是否属于异步这个问题，之前在早期的POSIX规范中是有差异的，但是当前已经取得一致了。异步I/O的定义：<strong>告知内核启动某个动作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。</strong></p>
<blockquote>
<p>这种模型与前一节介绍的信号驱动模型的主要区别在于：信号驱动式I/O是由内核通知我们何时启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。图6-5给出了一个例子。<br>我们调用aio<em>read函数（POSIX异步I/O函数以aio</em>或lio_开头），给内核传递描述符、缓冲区指针、缓冲区大小（与read相同的三个参数）和文件偏移（与lseek类似），并告诉内核当整个操作完成时如何通知我们。该系统调用立即返回，而且在等待I/O完成期间，我们的进程不被阻塞。本例子中我们假设要求内核在操作完成 时产生某个信号。该信号知道数据已经复制到进程缓冲区才产生，这一点不同于信号驱动式I/O模型。<br><em>本书编写至此，支持POSIX异步I/O模型的系统仍较罕见。我们不能确定这样的系统是否支持套接字上的这种模型。这儿我们只是用它作为一个与信号驱动式I/O模型相比照的例子</em></p>
</blockquote>
<p>根据上面的描述，我们可以知道，异步I/O跟信号驱动式I/O非常类似，只是</p>
<ol>
<li>它的第一步系统调用时需要注册的函数更加复杂，因为它需要告诉内核将数据传输到用户空间的具体位置以及数据的大小，同时还需要告知内核到时候需要调用什么回调函数。</li>
<li>内核也需要独立执行数据从网卡—》内核缓冲区（可能被跳过）—》用户缓冲区的操作。</li>
</ol>
<p>总结来看，最后一种模型来自POSIX的定义，它定义了何谓I/O模型的异步，只有完全异步的模型才叫做异步I/O模型。事件驱动模型（I/O复用）和信号驱动模型都有异步的成分，但是都不是完全的异步，他们都需要线程自行完成数据复制的一部分工作，而异步I/O模型不需要。</p>
<p><strong>但是</strong>，从《UNIX网络编程卷一》的表述来看，目前还很少有系统真正的实现异步I/O模型。</p>
<h3 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h3><p>有一个小问题是，数据报的复制期间，线程到底阻塞与否，分两种情况：</p>
<ol>
<li>不阻塞，从内核空间复制数据到应用程序缓存是内存领域的复杂，CPU直接参与</li>
<li>阻塞，等待I/O管理组件完成数据的复制。</li>
</ol>
<p>从本质来说，这个问题跟前面的小结——I/O操作谁来执行——是一致的，但是这是内存上的I/O，CPU是可以直接访问的，所以情况可能会不同于硬盘和网络I/O。我个人觉得是阻塞的，因为如果CPU接入的话恐怕有点太浪费，但是这一点我没有专门去考证。</p>
<p>但是又有什么关系呢？其实这个环节阻塞还是不阻塞对于我们充分理解I/O模型以及优化性能没有任何影响。<br>对于异步I/O模型来说，此阶段由内核完成，我们的线程不参与，只听最终通知就可以。对于其他I/O模型来说，此阶段是由我们的线程必须参与的，它阻塞还是不阻塞都必须执行或者等待。所以一方面是不需要关心，一方面是必须等待它完成，没有任何可优化空间，那我们关心它干嘛呢。</p>
<h2 id="五种模型的比较："><a href="#五种模型的比较：" class="headerlink" title="五种模型的比较："></a>五种模型的比较：</h2><p><img src="http://ozhp30d7a.bkt.clouddn.com/image/%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BUnixIO%E6%A8%A1%E5%9E%8B/5zhongmoxing.png" alt=""></p>
<p>比较以上5种模型，可见前四种都调用了<code>recvfrom</code>这个系统调用，而这个过程都导致了进程被阻塞。所以之后最后一个模型与POSIX所定义的异步I/O相匹配。</p>
<div class="note info"><p>注意！在《Unix网络编程 卷一》中提到了：只有异步模型才跟POSIX定义的异步I/O相匹配。我想说的是，我们是实践者，只需要区分出5种模型的区别，并有利于理解各种编程模型发挥它们各自的优势就OK了。而实际编程中遇到的很多框架、编程模型都称自己作品是异步的，这种说法往往是说用户线程间行为上的异步，并非是系统调用级别的I/O模型的异步。况且异步这个词也并不局限在操作系统的I/O模型上，所以这种说法和这里的结论也并不冲突。</p></div>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blogs/tags/I-O/" rel="tag"><i class="fa fa-tag"></i> I/O</a>
          
            <a href="/blogs/tags/系统调用/" rel="tag"><i class="fa fa-tag"></i> 系统调用</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blogs/2017/11/16/基于github-pages使用hexo搭建个人博客/" rel="next" title="基于github-pages使用hexo搭建个人博客">
                <i class="fa fa-chevron-left"></i> 基于github-pages使用hexo搭建个人博客
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blogs/2017/12/11/java传值还是传引用/" rel="prev" title="java传值还是传引用">
                java传值还是传引用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://ozhp30d7a.bkt.clouddn.com/index/header/shadowmoon-valley-1366x768.jpg"
                alt="Walker" />
            
              <p class="site-author-name" itemprop="name">Walker</p>
              <p class="site-description motion-element" itemprop="description">To be or not to be that's a question</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blogs/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blogs/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blogs/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#关于Unix-I-O模型的理解"><span class="nav-number">1.</span> <span class="nav-text">关于Unix I/O模型的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#系统调用"><span class="nav-number">1.1.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程阻塞"><span class="nav-number">1.2.</span> <span class="nav-text">线程阻塞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O操作谁来执行"><span class="nav-number">1.2.1.</span> <span class="nav-text">I/O操作谁来执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解Unix-5种-I-O模型"><span class="nav-number">1.3.</span> <span class="nav-text">理解Unix 5种 I/O模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞式io："><span class="nav-number">1.3.1.</span> <span class="nav-text">阻塞式io：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非阻塞式io："><span class="nav-number">1.3.2.</span> <span class="nav-text">非阻塞式io：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io复用："><span class="nav-number">1.3.3.</span> <span class="nav-text">io复用：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非阻塞I-O和I-O复用的思路不同"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">非阻塞I/O和I/O复用的思路不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题在于执行顺序"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">问题在于执行顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O复用的阻塞"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">I/O复用的阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O复用小结"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">I/O复用小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号驱动io："><span class="nav-number">1.3.4.</span> <span class="nav-text">信号驱动io：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#信号驱动-VS-I-O复用"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">信号驱动 VS I/O复用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步io："><span class="nav-number">1.3.5.</span> <span class="nav-text">异步io：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个小问题"><span class="nav-number">1.3.6.</span> <span class="nav-text">一个小问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五种模型的比较："><span class="nav-number">1.4.</span> <span class="nav-text">五种模型的比较：</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Walker</span>

  
</div>


  <!--<div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>-->




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/blogs/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/blogs/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/blogs/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/blogs/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blogs/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blogs/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/blogs/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/blogs/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/blogs/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/blogs/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/blogs/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/blogs/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/blogs/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/blogs/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
